{
  "LOG": {
    "wast": "(func $LOG\n  (param $number i32)\n\n  (local $offset i32)\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  (local $length i32)\n  (local $length0 i64)\n  (local $length1 i64)\n  (local $length2 i64)\n  (local $length3 i64)\n\n  (set_local $offset0 (i64.load          (get_global $sp)))\n  (set_local $offset1 (i64.load (i32.add (get_global $sp) (i32.const  8))))\n  (set_local $offset2 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $offset3 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n\n  (set_local $length0 (i64.load (i32.sub (get_global $sp) (i32.const 32))))\n  (set_local $length1 (i64.load (i32.sub (get_global $sp) (i32.const 24))))\n  (set_local $length2 (i64.load (i32.sub (get_global $sp) (i32.const 16))))\n  (set_local $length3 (i64.load (i32.sub (get_global $sp) (i32.const  8))))\n\n  (set_local $offset \n             (call $check_overflow (get_local $offset0)\n                                   (get_local $offset1)\n                                   (get_local $offset2)\n                                   (get_local $offset3)))\n\n  (set_local $length\n             (call $check_overflow (get_local $length0)\n                                   (get_local $length1)\n                                   (get_local $length2)\n                                   (get_local $length3)))\n\n  (call $memusegas (get_local $offset) (get_local $length))\n\n  (call $log \n             (get_local $offset)\n             (get_local $length)\n             (get_local $number)\n             (i32.sub (get_global $sp) (i32.const  64))\n             (i32.sub (get_global $sp) (i32.const  96))\n             (i32.sub (get_global $sp) (i32.const 128))\n             (i32.sub (get_global $sp) (i32.const 160)))\n)\n",
    "imports": "(import \"ethereum\" \"log\" (func $log (param i32 i32 i32 i32 i32 i32 i32) ))"
  },
  "CALLDATALOAD": {
    "wast": ";; stack:\n;;  0: dataOffset\n(func $CALLDATALOAD\n  (local $writeOffset i32)\n  (local $writeOffset0 i64)\n  (local $writeOffset1 i64)\n  (local $writeOffset2 i64)\n  (local $writeOffset3 i64)\n\n  (set_local $writeOffset0 (i64.load (i32.add (get_global $sp) (i32.const  0))))\n  (set_local $writeOffset1 (i64.load (i32.add (get_global $sp) (i32.const  8))))\n  (set_local $writeOffset2 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $writeOffset3 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n\n  (i64.store (i32.add (get_global $sp) (i32.const  0)) (i64.const 0))\n  (i64.store (i32.add (get_global $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (get_global $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_global $sp) (i32.const 24)) (i64.const 0))\n\n  (set_local $writeOffset\n             (call $check_overflow (get_local $writeOffset0)\n                                   (get_local $writeOffset1)\n                                   (get_local $writeOffset2)\n                                   (get_local $writeOffset3)))\n\n  (call $callDataCopy256 (get_global $sp) (get_local $writeOffset))\n  ;; swap top stack item\n  (drop (call $bswap_m256 (get_global $sp)))\n)\n",
    "imports": "(import \"ethereum\" \"callDataCopy256\" (func $callDataCopy256 (param i32 i32) ))"
  },
  "GAS": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GAS   (i64.store (i32.add (get_global $sp) (i32.const 32)) (call $getGasLeft))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"getGasLeft\" (func $getGasLeft  (result i64)))"
  },
  "ADDRESS": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $ADDRESS   (call $getAddress (i32.add (get_global $sp) (i32.const 32)))\n    (drop (call $bswap_m160 (i32.add (get_global $sp) (i32.const 32))))\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i32.store (i32.add (get_global $sp) (i32.const 52)) (i32.const 0)))",
    "imports": "(import \"ethereum\" \"getAddress\" (func $getAddress (param i32) ))"
  },
  "BALANCE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $BALANCE   (call $getBalance(i32.add (i32.const 12) (call $bswap_m256 (get_global $sp))) (i32.add (get_global $sp) (i32.const 0)))\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 24)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 16)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"getBalance\" (func $getBalance (param i32 i32) ))"
  },
  "ORIGIN": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $ORIGIN   (call $getTxOrigin (i32.add (get_global $sp) (i32.const 32)))\n    (drop (call $bswap_m160 (i32.add (get_global $sp) (i32.const 32))))\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i32.store (i32.add (get_global $sp) (i32.const 52)) (i32.const 0)))",
    "imports": "(import \"ethereum\" \"getTxOrigin\" (func $getTxOrigin (param i32) ))"
  },
  "CALLER": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLER   (call $getCaller (i32.add (get_global $sp) (i32.const 32)))\n    (drop (call $bswap_m160 (i32.add (get_global $sp) (i32.const 32))))\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i32.store (i32.add (get_global $sp) (i32.const 52)) (i32.const 0)))",
    "imports": "(import \"ethereum\" \"getCaller\" (func $getCaller (param i32) ))"
  },
  "CALLVALUE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLVALUE   (call $getCallValue (i32.add (get_global $sp) (i32.const 32)))\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 48)) (i64.const 0))(drop (call $bswap_m128 (i32.add (i32.const 32)(get_global $sp)))))",
    "imports": "(import \"ethereum\" \"getCallValue\" (func $getCallValue (param i32) ))"
  },
  "CALLDATASIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLDATASIZE   (i64.store\n    (i32.add (get_global $sp) (i32.const 32))\n    (i64.extend_u/i32\n      (call $getCallDataSize)))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"getCallDataSize\" (func $getCallDataSize  (result i32)))"
  },
  "CALLDATACOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLDATACOPY (local $offset0 i32)(local $length0 i32) (set_local $offset0 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const 0)))\n      (i64.load (i32.add (get_global $sp) (i32.const 8)))\n      (i64.load (i32.add (get_global $sp) (i32.const 16)))\n      (i64.load (i32.add (get_global $sp) (i32.const 24)))))(set_local $length0 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -64)))\n      (i64.load (i32.add (get_global $sp) (i32.const -56)))\n      (i64.load (i32.add (get_global $sp) (i32.const -48)))\n      (i64.load (i32.add (get_global $sp) (i32.const -40)))))\n\n    (call $memusegas (get_local $offset0) (get_local $length0))\n    (set_local $offset0 (i32.add (get_global $memstart) (get_local $offset0))) (call $callDataCopy(get_local $offset0)(call $check_overflow\n           (i64.load (i32.add (get_global $sp) (i32.const -32)))\n           (i64.load (i32.add (get_global $sp) (i32.const -24)))\n           (i64.load (i32.add (get_global $sp) (i32.const -16)))\n           (i64.load (i32.add (get_global $sp) (i32.const -8))))(get_local $length0)))",
    "imports": "(import \"ethereum\" \"callDataCopy\" (func $callDataCopy (param i32 i32 i32) ))"
  },
  "CODESIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CODESIZE   (i64.store\n    (i32.add (get_global $sp) (i32.const 32))\n    (i64.extend_u/i32\n      (call $getCodeSize)))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"getCodeSize\" (func $getCodeSize  (result i32)))"
  },
  "CODECOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CODECOPY (local $offset0 i32)(local $length0 i32) (set_local $offset0 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const 0)))\n      (i64.load (i32.add (get_global $sp) (i32.const 8)))\n      (i64.load (i32.add (get_global $sp) (i32.const 16)))\n      (i64.load (i32.add (get_global $sp) (i32.const 24)))))(set_local $length0 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -64)))\n      (i64.load (i32.add (get_global $sp) (i32.const -56)))\n      (i64.load (i32.add (get_global $sp) (i32.const -48)))\n      (i64.load (i32.add (get_global $sp) (i32.const -40)))))\n\n    (call $memusegas (get_local $offset0) (get_local $length0))\n    (set_local $offset0 (i32.add (get_global $memstart) (get_local $offset0))) (call $codeCopy(get_local $offset0)(call $check_overflow\n           (i64.load (i32.add (get_global $sp) (i32.const -32)))\n           (i64.load (i32.add (get_global $sp) (i32.const -24)))\n           (i64.load (i32.add (get_global $sp) (i32.const -16)))\n           (i64.load (i32.add (get_global $sp) (i32.const -8))))(get_local $length0)))",
    "imports": "(import \"ethereum\" \"codeCopy\" (func $codeCopy (param i32 i32 i32) ))"
  },
  "EXTCODESIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $EXTCODESIZE   (i64.store\n    (i32.add (get_global $sp) (i32.const 0))\n    (i64.extend_u/i32\n      (call $getExternalCodeSize(i32.add (i32.const 12) (call $bswap_m256 (get_global $sp))))))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 24)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 16)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 8)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"getExternalCodeSize\" (func $getExternalCodeSize (param i32) (result i32)))"
  },
  "EXTCODECOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $EXTCODECOPY (local $offset0 i32)(local $length0 i32) (set_local $offset0 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const -32)))\n      (i64.load (i32.add (get_global $sp) (i32.const -24)))\n      (i64.load (i32.add (get_global $sp) (i32.const -16)))\n      (i64.load (i32.add (get_global $sp) (i32.const -8)))))(set_local $length0 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -96)))\n      (i64.load (i32.add (get_global $sp) (i32.const -88)))\n      (i64.load (i32.add (get_global $sp) (i32.const -80)))\n      (i64.load (i32.add (get_global $sp) (i32.const -72)))))\n\n    (call $memusegas (get_local $offset0) (get_local $length0))\n    (set_local $offset0 (i32.add (get_global $memstart) (get_local $offset0))) (call $externalCodeCopy(i32.add (i32.const 12) (call $bswap_m256 (get_global $sp)))(get_local $offset0)(call $check_overflow\n           (i64.load (i32.add (get_global $sp) (i32.const -64)))\n           (i64.load (i32.add (get_global $sp) (i32.const -56)))\n           (i64.load (i32.add (get_global $sp) (i32.const -48)))\n           (i64.load (i32.add (get_global $sp) (i32.const -40))))(get_local $length0)))",
    "imports": "(import \"ethereum\" \"externalCodeCopy\" (func $externalCodeCopy (param i32 i32 i32 i32) ))"
  },
  "GASPRICE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GASPRICE   (call $getTxGasPrice(i32.add (get_global $sp) (i32.const 32))))",
    "imports": "(import \"ethereum\" \"getTxGasPrice\" (func $getTxGasPrice (param i32) ))"
  },
  "BLOCKHASH": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $BLOCKHASH   (call $getBlockHash(call $check_overflow\n           (i64.load (i32.add (get_global $sp) (i32.const 0)))\n           (i64.load (i32.add (get_global $sp) (i32.const 8)))\n           (i64.load (i32.add (get_global $sp) (i32.const 16)))\n           (i64.load (i32.add (get_global $sp) (i32.const 24)))) \n    (i32.add (get_global $sp) \n    (i32.const 0)))\n      (drop (call $bswap_m256 (i32.add (i32.const 32) (get_global $sp))))\n      )",
    "imports": "(import \"ethereum\" \"getBlockHash\" (func $getBlockHash (param i32 i32) ))"
  },
  "COINBASE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $COINBASE   (call $getBlockCoinbase (i32.add (get_global $sp) (i32.const 32)))\n    (drop (call $bswap_m160 (i32.add (get_global $sp) (i32.const 32))))\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i32.store (i32.add (get_global $sp) (i32.const 52)) (i32.const 0)))",
    "imports": "(import \"ethereum\" \"getBlockCoinbase\" (func $getBlockCoinbase (param i32) ))"
  },
  "TIMESTAMP": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $TIMESTAMP   (i64.store (i32.add (get_global $sp) (i32.const 32)) (call $getBlockTimestamp))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"getBlockTimestamp\" (func $getBlockTimestamp  (result i64)))"
  },
  "NUMBER": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $NUMBER   (i64.store (i32.add (get_global $sp) (i32.const 32)) (call $getBlockNumber))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"getBlockNumber\" (func $getBlockNumber  (result i64)))"
  },
  "DIFFICULTY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $DIFFICULTY   (call $getBlockDifficulty(i32.add (get_global $sp) (i32.const 32))))",
    "imports": "(import \"ethereum\" \"getBlockDifficulty\" (func $getBlockDifficulty (param i32) ))"
  },
  "GASLIMIT": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GASLIMIT   (i64.store (i32.add (get_global $sp) (i32.const 32)) (call $getBlockGasLimit))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"getBlockGasLimit\" (func $getBlockGasLimit  (result i64)))"
  },
  "CREATE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CREATE (local $offset0 i32)(local $length0 i32) (set_local $offset0 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const -32)))\n      (i64.load (i32.add (get_global $sp) (i32.const -24)))\n      (i64.load (i32.add (get_global $sp) (i32.const -16)))\n      (i64.load (i32.add (get_global $sp) (i32.const -8)))))(set_local $length0 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -64)))\n      (i64.load (i32.add (get_global $sp) (i32.const -56)))\n      (i64.load (i32.add (get_global $sp) (i32.const -48)))\n      (i64.load (i32.add (get_global $sp) (i32.const -40)))))\n\n    (call $memusegas (get_local $offset0) (get_local $length0))\n    (set_local $offset0 (i32.add (get_global $memstart) (get_local $offset0))) (call $create(i32.add (i32.const 16) (call $bswap_m256 (get_global $sp)))(get_local $offset0)(get_local $length0) (i32.add (get_global $sp) (i32.const -64)))\n    (drop (call $bswap_m160 (i32.add (get_global $sp) (i32.const -64))))\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const -40)) (i64.const 0))\n    (i32.store (i32.add (get_global $sp) (i32.const -44)) (i32.const 0)))",
    "imports": "(import \"ethereum\" \"create\" (func $create (param i32 i32 i32 i32) ))"
  },
  "CALL": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALL (local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (set_local $offset0 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const -96)))\n      (i64.load (i32.add (get_global $sp) (i32.const -88)))\n      (i64.load (i32.add (get_global $sp) (i32.const -80)))\n      (i64.load (i32.add (get_global $sp) (i32.const -72)))))(set_local $length0 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -128)))\n      (i64.load (i32.add (get_global $sp) (i32.const -120)))\n      (i64.load (i32.add (get_global $sp) (i32.const -112)))\n      (i64.load (i32.add (get_global $sp) (i32.const -104)))))\n\n    (call $memusegas (get_local $offset0) (get_local $length0))\n    (set_local $offset0 (i32.add (get_global $memstart) (get_local $offset0)))(set_local $offset1 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const -160)))\n      (i64.load (i32.add (get_global $sp) (i32.const -152)))\n      (i64.load (i32.add (get_global $sp) (i32.const -144)))\n      (i64.load (i32.add (get_global $sp) (i32.const -136)))))(set_local $length1 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -192)))\n      (i64.load (i32.add (get_global $sp) (i32.const -184)))\n      (i64.load (i32.add (get_global $sp) (i32.const -176)))\n      (i64.load (i32.add (get_global $sp) (i32.const -168)))))\n\n    (call $memusegas (get_local $offset1) (get_local $length1))\n    (set_local $offset1 (i32.add (get_global $memstart) (get_local $offset1))) (i64.store\n    (i32.add (get_global $sp) (i32.const -192))\n    (i64.extend_u/i32\n      (call $call(call $check_overflow_i64\n           (i64.load (i32.add (get_global $sp) (i32.const 0)))\n           (i64.load (i32.add (get_global $sp) (i32.const 8)))\n           (i64.load (i32.add (get_global $sp) (i32.const 16)))\n           (i64.load (i32.add (get_global $sp) (i32.const 24))))(i32.add (i32.const 12) (call $bswap_m256 (i32.add (get_global $sp) (i32.const -32))))(i32.add (i32.const 16) (call $bswap_m256 (i32.add (get_global $sp) (i32.const -64))))(get_local $offset0)(get_local $length0)(get_local $offset1)(get_local $length1))))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const -168)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const -176)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const -184)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"call\" (func $call (param i64 i32 i32 i32 i32 i32 i32) (result i32)))"
  },
  "CALLCODE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLCODE (local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (set_local $offset0 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const -96)))\n      (i64.load (i32.add (get_global $sp) (i32.const -88)))\n      (i64.load (i32.add (get_global $sp) (i32.const -80)))\n      (i64.load (i32.add (get_global $sp) (i32.const -72)))))(set_local $length0 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -128)))\n      (i64.load (i32.add (get_global $sp) (i32.const -120)))\n      (i64.load (i32.add (get_global $sp) (i32.const -112)))\n      (i64.load (i32.add (get_global $sp) (i32.const -104)))))\n\n    (call $memusegas (get_local $offset0) (get_local $length0))\n    (set_local $offset0 (i32.add (get_global $memstart) (get_local $offset0)))(set_local $offset1 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const -160)))\n      (i64.load (i32.add (get_global $sp) (i32.const -152)))\n      (i64.load (i32.add (get_global $sp) (i32.const -144)))\n      (i64.load (i32.add (get_global $sp) (i32.const -136)))))(set_local $length1 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -192)))\n      (i64.load (i32.add (get_global $sp) (i32.const -184)))\n      (i64.load (i32.add (get_global $sp) (i32.const -176)))\n      (i64.load (i32.add (get_global $sp) (i32.const -168)))))\n\n    (call $memusegas (get_local $offset1) (get_local $length1))\n    (set_local $offset1 (i32.add (get_global $memstart) (get_local $offset1))) (i64.store\n    (i32.add (get_global $sp) (i32.const -192))\n    (i64.extend_u/i32\n      (call $callCode(call $check_overflow\n           (i64.load (i32.add (get_global $sp) (i32.const 0)))\n           (i64.load (i32.add (get_global $sp) (i32.const 8)))\n           (i64.load (i32.add (get_global $sp) (i32.const 16)))\n           (i64.load (i32.add (get_global $sp) (i32.const 24))))(i32.add (i32.const 12) (call $bswap_m256 (i32.add (get_global $sp) (i32.const -32))))(i32.add (i32.const 16) (call $bswap_m256 (i32.add (get_global $sp) (i32.const -64))))(get_local $offset0)(get_local $length0)(get_local $offset1)(get_local $length1))))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const -168)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const -176)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const -184)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"callCode\" (func $callCode (param i32 i32 i32 i32 i32 i32 i32) (result i32)))"
  },
  "DELEGATECALL": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $DELEGATECALL (local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (set_local $offset0 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const -96)))\n      (i64.load (i32.add (get_global $sp) (i32.const -88)))\n      (i64.load (i32.add (get_global $sp) (i32.const -80)))\n      (i64.load (i32.add (get_global $sp) (i32.const -72)))))(set_local $length0 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -128)))\n      (i64.load (i32.add (get_global $sp) (i32.const -120)))\n      (i64.load (i32.add (get_global $sp) (i32.const -112)))\n      (i64.load (i32.add (get_global $sp) (i32.const -104)))))\n\n    (call $memusegas (get_local $offset0) (get_local $length0))\n    (set_local $offset0 (i32.add (get_global $memstart) (get_local $offset0)))(set_local $offset1 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const -160)))\n      (i64.load (i32.add (get_global $sp) (i32.const -152)))\n      (i64.load (i32.add (get_global $sp) (i32.const -144)))\n      (i64.load (i32.add (get_global $sp) (i32.const -136)))))(set_local $length1 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -192)))\n      (i64.load (i32.add (get_global $sp) (i32.const -184)))\n      (i64.load (i32.add (get_global $sp) (i32.const -176)))\n      (i64.load (i32.add (get_global $sp) (i32.const -168)))))\n\n    (call $memusegas (get_local $offset1) (get_local $length1))\n    (set_local $offset1 (i32.add (get_global $memstart) (get_local $offset1))) (i64.store\n    (i32.add (get_global $sp) (i32.const -192))\n    (i64.extend_u/i32\n      (call $callDelegate(call $check_overflow\n           (i64.load (i32.add (get_global $sp) (i32.const 0)))\n           (i64.load (i32.add (get_global $sp) (i32.const 8)))\n           (i64.load (i32.add (get_global $sp) (i32.const 16)))\n           (i64.load (i32.add (get_global $sp) (i32.const 24))))(i32.add (i32.const 12) (call $bswap_m256 (i32.add (get_global $sp) (i32.const -32))))(i32.add (i32.const 16) (call $bswap_m256 (i32.add (get_global $sp) (i32.const -64))))(get_local $offset0)(get_local $length0)(get_local $offset1)(get_local $length1))))\n\n    ;; zero out mem\n    (i64.store (i32.add (get_global $sp) (i32.const -168)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const -176)) (i64.const 0))\n    (i64.store (i32.add (get_global $sp) (i32.const -184)) (i64.const 0)))",
    "imports": "(import \"ethereum\" \"callDelegate\" (func $callDelegate (param i32 i32 i32 i32 i32 i32 i32) (result i32)))"
  },
  "SSTORE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SSTORE   (call $storageStore(get_global $sp)(i32.add (get_global $sp) (i32.const -32))))",
    "imports": "(import \"ethereum\" \"storageStore\" (func $storageStore (param i32 i32) ))"
  },
  "SLOAD": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SLOAD   (call $storageLoad(get_global $sp) \n    (i32.add (get_global $sp) \n    (i32.const 0)))\n      (drop (call $bswap_m256 (i32.add (i32.const 32) (get_global $sp))))\n      )",
    "imports": "(import \"ethereum\" \"storageLoad\" (func $storageLoad (param i32 i32) ))"
  },
  "SELFDESTRUCT": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SELFDESTRUCT   (call $selfDestruct(i32.add (i32.const 12) (call $bswap_m256 (get_global $sp)))))",
    "imports": "(import \"ethereum\" \"selfDestruct\" (func $selfDestruct (param i32) ))"
  },
  "RETURN": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $RETURN (local $offset0 i32)(local $length0 i32) (set_local $offset0 \n    (call $check_overflow\n      (i64.load (i32.add (get_global $sp) (i32.const 0)))\n      (i64.load (i32.add (get_global $sp) (i32.const 8)))\n      (i64.load (i32.add (get_global $sp) (i32.const 16)))\n      (i64.load (i32.add (get_global $sp) (i32.const 24)))))(set_local $length0 \n    (call $check_overflow \n      (i64.load (i32.add (get_global $sp) (i32.const -32)))\n      (i64.load (i32.add (get_global $sp) (i32.const -24)))\n      (i64.load (i32.add (get_global $sp) (i32.const -16)))\n      (i64.load (i32.add (get_global $sp) (i32.const -8)))))\n\n    (call $memusegas (get_local $offset0) (get_local $length0))\n    (set_local $offset0 (i32.add (get_global $memstart) (get_local $offset0))) (call $return(get_local $offset0)(get_local $length0)))",
    "imports": "(import \"ethereum\" \"return\" (func $return (param i32 i32) ))"
  },
  "ADD": {
    "wast": "(func $ADD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $c i64)\n  (local $d i64)\n  (local $carry i64)\n\n  (set_local $sp (get_global $sp))\n  \n  ;; d c b a\n  ;; pop the stack \n  (set_local $a (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $c (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $d (i64.load (get_local $sp)))\n  ;; decement the stack pointer\n  (set_local $sp (i32.sub (get_local $sp) (i32.const 8)))\n\n  ;; d \n  (set_local $carry (i64.add (get_local $d) (i64.load (i32.sub (get_local $sp) (i32.const 24)))))\n  ;; save d  to mem\n  (i64.store (i32.sub (get_local $sp) (i32.const 24)) (get_local $carry))\n  ;; check  for overflow\n  (set_local $carry (i64.extend_u/i32 (i64.lt_u (get_local $carry) (get_local $d))))\n\n  ;; c use $d as reg\n  (set_local $d     (i64.add (i64.load (i32.sub (get_local $sp) (i32.const 16))) (get_local $carry)))\n  (set_local $carry (i64.extend_u/i32 (i64.lt_u (get_local $d) (get_local $carry))))\n  (set_local $d     (i64.add (get_local $c) (get_local $d)))\n  ;; store the result\n  (i64.store (i32.sub (get_local $sp) (i32.const 16)) (get_local $d))\n  ;; check overflow\n  (set_local $carry (i64.or (i64.extend_u/i32  (i64.lt_u (get_local $d) (get_local $c))) (get_local $carry)))\n\n  ;; b\n  ;; add carry\n  (set_local $d     (i64.add (i64.load (i32.sub (get_local $sp) (i32.const 8))) (get_local $carry)))\n  (set_local $carry (i64.extend_u/i32 (i64.lt_u (get_local $d) (get_local $carry))))\n\n  ;; use reg c\n  (set_local $c (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $d (i64.add (get_local $c) (get_local $d)))\n  (i64.store (i32.sub (get_local $sp) (i32.const 8)) (get_local $d))\n  ;; a\n  (i64.store (get_local $sp) \n             (i64.add        ;; add a \n               (get_local $a)\n               (i64.add\n                 (i64.load (get_local $sp))  ;; load the operand\n                 (i64.or  ;; carry \n                   (i64.extend_u/i32 (i64.lt_u (get_local $d) (get_local $c))) \n                   (get_local $carry)))))\n)\n"
  },
  "ADDMOD": {
    "wast": ";; stack:\n;;  0: A\n;; -1: B\n;; -2: MOD\n(func $ADDMOD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  (local $moda i64)\n  (local $modb i64)\n  (local $modc i64)\n  (local $modd i64)\n\n  (local $carry i64)\n\n  (set_local $sp (get_global $sp))\n\n  ;; load args from the stack\n  (set_local $a (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $c (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $d (i64.load (get_local $sp)))\n\n  (set_local $sp (i32.sub (get_local $sp) (i32.const 32)))\n\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $c1 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $d1 (i64.load (get_local $sp)))\n\n  (set_local $sp (i32.sub (get_local $sp) (i32.const 32)))\n\n  (set_local $moda (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $modb (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $modc (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $modd (i64.load (get_local $sp)))\n\n  ;; a * 64^3 + b*64^2 + c*64 + d \n  ;; d \n  (set_local $d     (i64.add (get_local $d1) (get_local $d)))\n  (set_local $carry (i64.extend_u/i32 (i64.lt_u (get_local $d) (get_local $d1))))\n  ;; c\n  (set_local $c     (i64.add (get_local $c) (get_local $carry)))\n  (set_local $carry (i64.extend_u/i32 (i64.lt_u (get_local $c) (get_local $carry))))\n  (set_local $c     (i64.add (get_local $c1) (get_local $c)))\n  (set_local $carry (i64.or (i64.extend_u/i32  (i64.lt_u (get_local $c) (get_local $c1))) (get_local $carry)))\n  ;; b\n  (set_local $b     (i64.add (get_local $b) (get_local $carry)))\n  (set_local $carry (i64.extend_u/i32 (i64.lt_u (get_local $b) (get_local $carry))))\n  (set_local $b     (i64.add (get_local $b1) (get_local $b)))\n  (set_local $carry (i64.or (i64.extend_u/i32  (i64.lt_u (get_local $b) (get_local $b1))) (get_local $carry)))\n  ;; a\n  (set_local $a     (i64.add (get_local $a) (get_local $carry)))\n  (set_local $carry (i64.extend_u/i32 (i64.lt_u (get_local $a) (get_local $carry))))\n  (set_local $a     (i64.add (get_local $a1) (get_local $a)))\n  (set_local $carry (i64.or (i64.extend_u/i32  (i64.lt_u (get_local $a) (get_local $a1))) (get_local $carry)))\n\n  (call $mod_320\n        (get_local $carry) (get_local $a)    (get_local $b)    (get_local $c)    (get_local $d)\n        (i64.const 0)      (get_local $moda) (get_local $modb) (get_local $modc) (get_local $modd) (get_local $sp))\n)\n"
  },
  "AND": {
    "wast": "(func $AND\n  (i64.store (i32.sub (get_global $sp) (i32.const 8))  (i64.and (i64.load (i32.sub (get_global $sp) (i32.const 8)))  (i64.load (i32.add (get_global $sp) (i32.const 24)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 16)) (i64.and (i64.load (i32.sub (get_global $sp) (i32.const 16))) (i64.load (i32.add (get_global $sp) (i32.const 16)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 24)) (i64.and (i64.load (i32.sub (get_global $sp) (i32.const 24))) (i64.load (i32.add (get_global $sp) (i32.const 8)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 32)) (i64.and (i64.load (i32.sub (get_global $sp) (i32.const 32))) (i64.load (get_global $sp))))\n)\n"
  },
  "BYTE": {
    "wast": ";; stack:\n;;  0: offset\n;; -1: value\n(func $BYTE\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (set_local $sp (get_global $sp))\n\n  (set_local $a0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $a2 (i64.load (i32.add (get_local $sp) (i32.const  8))))\n  (set_local $a3 (i64.load          (get_local $sp)))\n\n  (set_local $sp (i32.sub (get_local $sp) (i32.const 32)))\n\n  (i64.store (get_local $sp)\n    (if (result i64)\n      (i32.and \n          (i32.and \n            (i32.and \n              (i64.lt_u (get_local $a3) (i64.const 32))\n              (i64.eqz (get_local $a2))) \n            (i64.eqz (get_local $a1)))\n          (i64.eqz (get_local $a0)))\n      (i64.load8_u (i32.sub (i32.const 31)(i32.wrap/i64 (get_local $a3))))\n      (i64.const 0)))\n\n  ;; zero out the rest of the stack\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 8))  (i64.const 0))\n)\n"
  },
  "DIV": {
    "wast": "(func $DIV\n  (local $sp i32)\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp  i64)\n  (local $temp2  i64)\n\n  (set_local $sp (get_global $sp))\n  (set_local $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (set_local $a (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $c (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $d (i64.load (get_local $sp)))\n\n  (set_local $sp (i32.sub (get_local $sp) (i32.const 32)))\n\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $c1 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $d1 (i64.load (get_local $sp)))\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1))\n      (br $main)\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if \n          ;; check to make sure we are not overflowing\n          (i32.or (i64.eqz (i64.clz (get_local $a1)))\n          ;;  divisor < dividend\n          (call $gte_256 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $a) (get_local $b) (get_local $c) (get_local $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (set_local $a1 (i64.add (i64.shl (get_local $a1) (i64.const 1)) (i64.shr_u (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shl (get_local $b1) (i64.const 1)) (i64.shr_u (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shl (get_local $c1) (i64.const 1)) (i64.shr_u (get_local $d1) (i64.const 63))))\n        (set_local $d1 (i64.shl (get_local $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (set_local $maska (i64.add (i64.shl (get_local $maska) (i64.const 1)) (i64.shr_u (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shl (get_local $maskb) (i64.const 1)) (i64.shr_u (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shl (get_local $maskc) (i64.const 1)) (i64.shr_u (get_local $maskd) (i64.const 63))))\n        (set_local $maskd (i64.shl (get_local $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (get_local $maska) (get_local $maskb) (get_local $maskc) (get_local $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (get_local $a) (get_local $b) (get_local $c) (get_local $d) (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (set_local $carry (i64.lt_u (get_local $d) (get_local $d1)))\n            (set_local $d     (i64.sub  (get_local $d) (get_local $d1)))\n            (set_local $temp  (i64.sub  (get_local $c) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $c)))\n            (set_local $c     (i64.sub  (get_local $temp) (get_local $c1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $c) (get_local $temp)) (get_local $carry)))\n            (set_local $temp  (i64.sub  (get_local $b) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $b)))\n            (set_local $b     (i64.sub  (get_local $temp) (get_local $b1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $b) (get_local $temp)) (get_local $carry)))\n            (set_local $a     (i64.sub  (i64.sub (get_local $a) (i64.extend_u/i32 (get_local $carry))) (get_local $a1)))\n\n            ;; result = result + mask\n            (set_local $dq   (i64.add (get_local $maskd) (get_local $dq)))\n            (set_local $temp (i64.extend_u/i32 (i64.lt_u (get_local $dq) (get_local $maskd))))\n            (set_local $cq   (i64.add (get_local $cq) (get_local $temp)))\n            (set_local $temp (i64.extend_u/i32 (i64.lt_u (get_local $cq) (get_local $temp))))\n            (set_local $cq   (i64.add (get_local $maskc) (get_local $cq)))\n            (set_local $temp (i64.or (i64.extend_u/i32  (i64.lt_u (get_local $cq) (get_local $maskc))) (get_local $temp)))\n            (set_local $bq   (i64.add (get_local $bq) (get_local $temp)))\n            (set_local $temp (i64.extend_u/i32 (i64.lt_u (get_local $bq) (get_local $temp))))\n            (set_local $bq   (i64.add (get_local $maskb) (get_local $bq)))\n            (set_local $aq   (i64.add (get_local $maska) (i64.add (get_local $aq) (i64.or (i64.extend_u/i32 (i64.lt_u (get_local $bq) (get_local $maskb))) (get_local $temp)))))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (set_local $d1 (i64.add (i64.shr_u (get_local $d1) (i64.const 1)) (i64.shl (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shr_u (get_local $c1) (i64.const 1)) (i64.shl (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shr_u (get_local $b1) (i64.const 1)) (i64.shl (get_local $a1) (i64.const 63))))\n        (set_local $a1 (i64.shr_u (get_local $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (set_local $maskd (i64.add (i64.shr_u (get_local $maskd) (i64.const 1)) (i64.shl (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shr_u (get_local $maskc) (i64.const 1)) (i64.shl (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shr_u (get_local $maskb) (i64.const 1)) (i64.shl (get_local $maska) (i64.const 63))))\n        (set_local $maska (i64.shr_u (get_local $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $aq))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $bq))\n  (i64.store (i32.add (get_local $sp) (i32.const 8))  (get_local $cq))\n  (i64.store (get_local $sp) (get_local $dq))\n)\n"
  },
  "DUP": {
    "wast": "(func $DUP\n  (param $a0 i32)\n  (local $sp i32)\n\n  (local $sp_ref i32)\n  \n  (set_local $sp (i32.add (get_global $sp) (i32.const 32)))\n  (set_local $sp_ref (i32.sub (i32.sub (get_local $sp) (i32.const 8)) (i32.mul (get_local $a0) (i32.const 32))))\n  \n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.load (get_local $sp_ref)))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.load (i32.sub (get_local $sp_ref) (i32.const 8))))\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (i64.load (i32.sub (get_local $sp_ref) (i32.const 16))))\n  (i64.store          (get_local $sp)                 (i64.load (i32.sub (get_local $sp_ref) (i32.const 24))))\n)\n"
  },
  "EQ": {
    "wast": "(func $EQ\n  (local $sp i32)\n\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n  (i64.store (get_local $sp)\n    (i64.extend_u/i32\n      (i32.and (i64.eq   (i64.load (i32.add (get_local $sp) (i32.const 56))) (i64.load (i32.add (get_local $sp) (i32.const 24))))\n      (i32.and (i64.eq   (i64.load (i32.add (get_local $sp) (i32.const 48))) (i64.load (i32.add (get_local $sp) (i32.const 16))))\n      (i32.and (i64.eq   (i64.load (i32.add (get_local $sp) (i32.const 40))) (i64.load (i32.add (get_local $sp) (i32.const  8))))\n               (i64.eq   (i64.load (i32.add (get_local $sp) (i32.const 32))) (i64.load          (get_local $sp))))))))\n\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (i64.const 0))\n)\n"
  },
  "EXP": {
    "wast": "(func $EXP\n  (local $sp i32)\n\n  ;; base\n  (local $base0 i64)\n  (local $base1 i64)\n  (local $base2 i64)\n  (local $base3 i64)\n\n  ;; exp\n  (local $exp0 i64)\n  (local $exp1 i64)\n  (local $exp2 i64)\n  (local $exp3 i64)\n\n  (local $r0 i64)\n  (local $r1 i64)\n  (local $r2 i64)\n  (local $r3 i64)\n\n  (local $gasCounter i32)\n  (set_local $sp (get_global $sp))\n\n  ;; load args from the stack\n  (set_local $base0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $base1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $base2 (i64.load (i32.add (get_local $sp) (i32.const  8))))\n  (set_local $base3 (i64.load          (get_local $sp)))\n\n  (set_local $sp (i32.sub (get_local $sp) (i32.const 32)))\n\n  (set_local $exp0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $exp1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $exp2 (i64.load (i32.add (get_local $sp) (i32.const  8))))\n  (set_local $exp3 (i64.load          (get_local $sp)))\n\n  ;; let result = new BN[1]\n  (set_local $r3 (i64.const 1))\n\n  (block $done\n    (loop $loop\n       ;; while [exp > 0] {\n      (if (call $iszero_256 (get_local $exp0) (get_local $exp1) (get_local $exp2) (get_local $exp3))\n        (br $done) \n      )\n\n      ;; if[exp.modn[2] === 1]\n      ;; is odd?\n      (if (i64.eqz (i64.ctz (get_local $exp3)))\n\n        ;; result = result.mul[base].mod[TWO_POW256]\n        ;; r = r * a\n        (then\n          (call $mul_256 (get_local $r0) (get_local $r1) (get_local $r2) (get_local $r3) (get_local $base0) (get_local $base1) (get_local $base2) (get_local $base3) (i32.add (get_local $sp) (i32.const 24)))\n          (set_local $r0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n          (set_local $r1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n          (set_local $r2 (i64.load (i32.add (get_local $sp) (i32.const  8))))\n          (set_local $r3 (i64.load          (get_local $sp)))\n        )\n      )\n      ;; exp = exp.shrn 1\n      (set_local $exp3 (i64.add (i64.shr_u (get_local $exp3) (i64.const 1)) (i64.shl (get_local $exp2) (i64.const 63))))\n      (set_local $exp2 (i64.add (i64.shr_u (get_local $exp2) (i64.const 1)) (i64.shl (get_local $exp1) (i64.const 63))))\n      (set_local $exp1 (i64.add (i64.shr_u (get_local $exp1) (i64.const 1)) (i64.shl (get_local $exp0) (i64.const 63))))\n      (set_local $exp0 (i64.shr_u (get_local $exp0) (i64.const 1)))\n\n      ;; base = base.mulr[baser].modr[TWO_POW256]\n      (call $mul_256 (get_local $base0) (get_local $base1) (get_local $base2) (get_local $base3) (get_local $base0) (get_local $base1) (get_local $base2) (get_local $base3) (i32.add (get_local $sp) (i32.const 24)))\n      (set_local $base0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n      (set_local $base1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n      (set_local $base2 (i64.load (i32.add (get_local $sp) (i32.const  8))))\n      (set_local $base3 (i64.load          (get_local $sp)))\n\n      (set_local $gasCounter (i32.add (get_local $gasCounter) (i32.const 1)))\n      (br $loop)\n    )\n  ) \n\n  ;; use gas\n  ;; Log256[Exponent] * 10\n  (call $useGas\n    (i64.extend_u/i32\n      (i32.mul\n        (i32.const 10)\n        (i32.div_u\n          (i32.add (get_local $gasCounter) (i32.const 7))\n          (i32.const 8)))))\n\n  ;; decement the stack pointer\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $r0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $r1))\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (get_local $r2))\n  (i64.store          (get_local $sp)                 (get_local $r3))\n)\n"
  },
  "GT": {
    "wast": "(func $GT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  (set_local $sp (get_global $sp))\n\n  ;; load args from the stack\n  (set_local $a0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $a2 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $a3 (i64.load (get_local $sp)))\n\n  (set_local $sp (i32.sub (get_local $sp) (i32.const 32)))\n\n  (set_local $b0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $b2 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $b3 (i64.load (get_local $sp)))\n\n  (i64.store (get_local $sp) (i64.extend_u/i32 \n    (i32.or (i64.gt_u (get_local $a0) (get_local $b0)) ;; a0 > b0\n    (i32.and (i64.eq   (get_local $a0) (get_local $b0)) ;; a0 == a1\n    (i32.or  (i64.gt_u (get_local $a1) (get_local $b1)) ;; a1 > b1\n    (i32.and (i64.eq   (get_local $a1) (get_local $b1)) ;; a1 == b1\n    (i32.or  (i64.gt_u (get_local $a2) (get_local $b2)) ;; a2 > b2\n    (i32.and (i64.eq   (get_local $a2) (get_local $b2)) ;; a2 == b2\n             (i64.gt_u (get_local $a3) (get_local $b3)))))))))) ;; a3 > b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "ISZERO": {
    "wast": "(func $ISZERO\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n\n  ;; load args from the stack\n  (set_local $a0 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $a1 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $a2 (i64.load (i32.add (get_global $sp) (i32.const 8))))\n  (set_local $a3 (i64.load (get_global $sp)))\n\n  (i64.store (get_global $sp)\n    (i64.extend_u/i32\n      (call $iszero_256 (get_local $a0) (get_local $a1) (get_local $a2) (get_local $a3))\n    )\n  )\n\n  ;; zero out the rest of memory\n  (i64.store (i32.add (get_global $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (get_global $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_global $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "LT": {
    "wast": "(func $LT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  (set_local $sp (get_global $sp))\n\n  ;; load args from the stack\n  (set_local $a0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $a2 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $a3 (i64.load (get_local $sp)))\n\n  (set_local $sp (i32.sub (get_local $sp) (i32.const 32)))\n\n  (set_local $b0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $b2 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $b3 (i64.load (get_local $sp)))\n\n  (i64.store (get_local $sp) (i64.extend_u/i32 \n    (i32.or  (i64.lt_u (get_local $a0) (get_local $b0)) ;; a0 < b0\n    (i32.and (i64.eq   (get_local $a0) (get_local $b0)) ;; a0 == b0\n    (i32.or  (i64.lt_u (get_local $a1) (get_local $b1)) ;; a1 < b1\n    (i32.and (i64.eq   (get_local $a1) (get_local $b1)) ;; a1 == b1\n    (i32.or  (i64.lt_u (get_local $a2) (get_local $b2)) ;; a2 < b2\n    (i32.and (i64.eq   (get_local $a2) (get_local $b2)) ;; a2 == b2\n             (i64.lt_u (get_local $a3) (get_local $b3)))))))))) ;; a3 < b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "MLOAD": {
    "wast": ";; stack:\n;;  0: offset\n(func $MLOAD\n  (local $offset i32)\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (set_local $offset0 (i64.load          (get_global $sp)))\n  (set_local $offset1 (i64.load (i32.add (get_global $sp) (i32.const 8))))\n  (set_local $offset2 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $offset3 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n\n  (set_local $offset \n             (call $check_overflow (get_local $offset0)\n                                   (get_local $offset1)\n                                   (get_local $offset2)\n                                   (get_local $offset3)))\n  ;; subttract gas useage\n  (call $memusegas (get_local $offset) (i32.const  32))\n\n  ;; FIXME: how to deal with overflow?\n  (set_local $offset (i32.add (get_local $offset) (get_global $memstart)))\n\n  (i64.store (i32.add (get_global $sp) (i32.const 24)) (i64.load (i32.add (get_local $offset) (i32.const 24))))\n  (i64.store (i32.add (get_global $sp) (i32.const 16)) (i64.load (i32.add (get_local $offset) (i32.const 16))))\n  (i64.store (i32.add (get_global $sp) (i32.const  8)) (i64.load (i32.add (get_local $offset) (i32.const  8))))\n  (i64.store          (get_global $sp)                 (i64.load          (get_local $offset)))\n\n  ;; swap\n  (drop (call $bswap_m256 (get_global $sp)))\n)\n"
  },
  "MOD": {
    "wast": "(func $MOD\n  (local $sp i32)\n\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp i64)\n\n  (set_local $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (set_local $a (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $b (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $c (i64.load (i32.add (get_global $sp) (i32.const  8))))\n  (set_local $d (i64.load          (get_global $sp)))\n  ;; decement the stack pointer\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $c1 (i64.load (i32.add (get_local $sp) (i32.const  8))))\n  (set_local $d1 (i64.load          (get_local $sp)))\n\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1))\n      (then\n        (set_local $a (i64.const 0))\n        (set_local $b (i64.const 0))\n        (set_local $c (i64.const 0))\n        (set_local $d (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n        (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (get_local $a1))) (call $gte_256 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $a) (get_local $b) (get_local $c) (get_local $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (set_local $a1 (i64.add (i64.shl (get_local $a1) (i64.const 1)) (i64.shr_u (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shl (get_local $b1) (i64.const 1)) (i64.shr_u (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shl (get_local $c1) (i64.const 1)) (i64.shr_u (get_local $d1) (i64.const 63))))\n        (set_local $d1 (i64.shl (get_local $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (set_local $maska (i64.add (i64.shl (get_local $maska) (i64.const 1)) (i64.shr_u (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shl (get_local $maskb) (i64.const 1)) (i64.shr_u (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shl (get_local $maskc) (i64.const 1)) (i64.shr_u (get_local $maskd) (i64.const 63))))\n        (set_local $maskd (i64.shl (get_local $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (get_local $maska) (get_local $maskb) (get_local $maskc) (get_local $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (get_local $a) (get_local $b) (get_local $c) (get_local $d) (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (set_local $carry (i64.lt_u (get_local $d) (get_local $d1)))\n            (set_local $d     (i64.sub  (get_local $d) (get_local $d1)))\n            (set_local $temp  (i64.sub  (get_local $c) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $c)))\n            (set_local $c     (i64.sub  (get_local $temp) (get_local $c1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $c) (get_local $temp)) (get_local $carry)))\n            (set_local $temp  (i64.sub  (get_local $b) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $b)))\n            (set_local $b     (i64.sub  (get_local $temp) (get_local $b1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $b) (get_local $temp)) (get_local $carry)))\n            (set_local $a     (i64.sub  (i64.sub (get_local $a) (i64.extend_u/i32 (get_local $carry))) (get_local $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (set_local $d1 (i64.add (i64.shr_u (get_local $d1) (i64.const 1)) (i64.shl (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shr_u (get_local $c1) (i64.const 1)) (i64.shl (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shr_u (get_local $b1) (i64.const 1)) (i64.shl (get_local $a1) (i64.const 63))))\n        (set_local $a1 (i64.shr_u (get_local $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (set_local $maskd (i64.add (i64.shr_u (get_local $maskd) (i64.const 1)) (i64.shl (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shr_u (get_local $maskc) (i64.const 1)) (i64.shl (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shr_u (get_local $maskb) (i64.const 1)) (i64.shl (get_local $maska) (i64.const 63))))\n        (set_local $maska (i64.shr_u (get_local $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $a))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $b))\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (get_local $c))\n  (i64.store          (get_local $sp)                 (get_local $d))\n)\n"
  },
  "MSIZE": {
    "wast": "(func $MSIZE\n  (local $sp i32)\n\n  ;; there's no input item for us to overwrite\n  (set_local $sp (i32.add (get_global $sp) (i32.const 32)))\n\n  (i64.store (i32.add (get_local $sp) (i32.const 0)) \n             (i64.mul (get_global $wordCount) (i64.const 32)))\n  (i64.store (i32.add (get_local $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "MSTORE": {
    "wast": ";; stack:\n;;  0: word\n;; -1: offset\n(func $MSTORE\n  (local $sp i32)\n\n  (local $offset   i32)\n  \n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (set_local $offset0 (i64.load          (get_global $sp)))\n  (set_local $offset1 (i64.load (i32.add (get_global $sp) (i32.const 8))))\n  (set_local $offset2 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $offset3 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n\n  (set_local $offset \n             (call $check_overflow (get_local $offset0)\n                                   (get_local $offset1)\n                                   (get_local $offset2)\n                                   (get_local $offset3)))\n  ;; subtrace gas useage\n  (call $memusegas (get_local $offset) (i32.const 32))\n\n  ;; pop itme from the stack\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n\n  ;; swap top stack item\n  (drop (call $bswap_m256 (get_local $sp)))\n\n  (set_local $offset (i32.add (get_local $offset) (get_global $memstart)))\n  ;; store word to memory\n  (i64.store          (get_local $offset)                 (i64.load          (get_local $sp)))\n  (i64.store (i32.add (get_local $offset) (i32.const 8))  (i64.load (i32.add (get_local $sp) (i32.const  8))))\n  (i64.store (i32.add (get_local $offset) (i32.const 16)) (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (i64.store (i32.add (get_local $offset) (i32.const 24)) (i64.load (i32.add (get_local $sp) (i32.const 24))))\n)\n"
  },
  "MSTORE8": {
    "wast": ";; stack:\n;;  0: word\n;; -1: offset\n(func $MSTORE8\n  (local $sp i32)\n\n  (local $offset i32)\n\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (set_local $offset0 (i64.load          (get_global $sp)))\n  (set_local $offset1 (i64.load (i32.add (get_global $sp) (i32.const 8))))\n  (set_local $offset2 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $offset3 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n\n  (set_local $offset \n             (call $check_overflow (get_local $offset0)\n                                   (get_local $offset1)\n                                   (get_local $offset2)\n                                   (get_local $offset3)))\n\n  (call $memusegas (get_local $offset) (i32.const 8))\n\n  ;; pop stack\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n  (set_local $offset (i32.add (get_local $offset) (get_global $memstart)))\n  (i32.store8 (i32.add (get_local $offset) (i32.const 0)) (i32.load (get_local $sp)))\n)\n"
  },
  "MUL": {
    "wast": "(func $MUL\n  (call $mul_256\n        (i64.load (i32.add (get_global $sp) (i32.const 24)))\n        (i64.load (i32.add (get_global $sp) (i32.const 16)))\n        (i64.load (i32.add (get_global $sp) (i32.const  8)))\n        (i64.load          (get_global $sp))\n        (i64.load (i32.sub (get_global $sp) (i32.const  8)))\n        (i64.load (i32.sub (get_global $sp) (i32.const 16)))\n        (i64.load (i32.sub (get_global $sp) (i32.const 24)))\n        (i64.load (i32.sub (get_global $sp) (i32.const 32)))\n        (i32.sub (get_global $sp) (i32.const 8))\n  )\n)\n"
  },
  "MULMOD": {
    "wast": "(func $MULMOD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $c i64)\n  (local $e i64)\n  (local $g i64)\n  (local $i i64)\n  (local $k i64)\n  (local $m i64)\n  (local $o i64)\n  (local $b i64)\n  (local $d i64)\n  (local $f i64)\n  (local $h i64)\n  (local $j i64)\n  (local $l i64)\n  (local $n i64)\n  (local $p i64)\n  (local $temp7 i64)\n  (local $temp6 i64)\n  (local $temp5 i64)\n  (local $temp4 i64)\n  (local $temp3 i64)\n  (local $temp2 i64)\n  (local $temp1 i64)\n  (local $temp0 i64)\n  (local $rowCarry i64)\n\n  (local $moda i64)\n  (local $modb i64)\n  (local $modc i64)\n  (local $modd i64)\n\n  ;; pop two items of the stack\n  (set_local $a (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $c (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $e (i64.load (i32.add (get_global $sp) (i32.const  8))))\n  (set_local $g (i64.load          (get_global $sp)))\n  (set_local $i (i64.load (i32.sub (get_global $sp) (i32.const  8))))\n  (set_local $k (i64.load (i32.sub (get_global $sp) (i32.const 16))))\n  (set_local $m (i64.load (i32.sub (get_global $sp) (i32.const 24))))\n  (set_local $o (i64.load (i32.sub (get_global $sp) (i32.const 32))))\n\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 64)))\n\n  ;; MUL\n  ;;  a b c d e f g h\n  ;;* i j k l m n o p\n  ;;----------------\n\n  ;; split the ops\n  (set_local $b (i64.and (get_local $a) (i64.const 4294967295)))\n  (set_local $a (i64.shr_u (get_local $a) (i64.const 32))) \n\n  (set_local $d (i64.and (get_local $c) (i64.const 4294967295)))\n  (set_local $c (i64.shr_u (get_local $c) (i64.const 32))) \n\n  (set_local $f (i64.and (get_local $e) (i64.const 4294967295)))\n  (set_local $e (i64.shr_u (get_local $e) (i64.const 32)))\n\n  (set_local $h (i64.and (get_local $g) (i64.const 4294967295)))\n  (set_local $g (i64.shr_u (get_local $g) (i64.const 32)))\n\n  (set_local $j (i64.and (get_local $i) (i64.const 4294967295)))\n  (set_local $i (i64.shr_u (get_local $i) (i64.const 32))) \n\n  (set_local $l (i64.and (get_local $k) (i64.const 4294967295)))\n  (set_local $k (i64.shr_u (get_local $k) (i64.const 32))) \n\n  (set_local $n (i64.and (get_local $m) (i64.const 4294967295)))\n  (set_local $m (i64.shr_u (get_local $m) (i64.const 32)))\n\n  (set_local $p (i64.and (get_local $o) (i64.const 4294967295)))\n  (set_local $o (i64.shr_u (get_local $o) (i64.const 32)))\n\n   ;; first row multiplication \n  ;; p * h\n  (set_local $temp0 (i64.mul (get_local $p) (get_local $h)))\n  ;; p * g + carry\n  (set_local $temp1 (i64.add (i64.mul (get_local $p) (get_local $g)) (i64.shr_u (get_local $temp0) (i64.const 32))))\n  ;; p * f + carry\n  (set_local $temp2 (i64.add (i64.mul (get_local $p) (get_local $f)) (i64.shr_u (get_local $temp1) (i64.const 32))))\n  ;; p * e + carry\n  (set_local $temp3 (i64.add (i64.mul (get_local $p) (get_local $e)) (i64.shr_u (get_local $temp2) (i64.const 32))))\n  ;; p * d + carry\n  (set_local $temp4 (i64.add (i64.mul (get_local $p) (get_local $d)) (i64.shr_u (get_local $temp3) (i64.const 32))))\n  ;; p * c + carry\n  (set_local $temp5 (i64.add (i64.mul (get_local $p) (get_local $c)) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; p * b + carry\n  (set_local $temp6 (i64.add (i64.mul (get_local $p) (get_local $b)) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; p * a + carry\n  (set_local $temp7 (i64.add (i64.mul (get_local $p) (get_local $a)) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  (set_local $rowCarry (i64.shr_u (get_local $temp7) (i64.const 32)))\n\n  ;; second row\n  ;; o * h + $temp1 \n  (set_local $temp1 (i64.add (i64.mul (get_local $o) (get_local $h)) (i64.and (get_local $temp1) (i64.const 4294967295))))\n  ;; o * g + $temp2 + carry\n  (set_local $temp2 (i64.add (i64.add (i64.mul (get_local $o) (get_local $g)) (i64.and (get_local $temp2) (i64.const 4294967295))) (i64.shr_u (get_local $temp1) (i64.const 32))))\n  ;; o * f + $temp3 + carry\n  (set_local $temp3 (i64.add (i64.add (i64.mul (get_local $o) (get_local $f)) (i64.and (get_local $temp3) (i64.const 4294967295))) (i64.shr_u (get_local $temp2) (i64.const 32))))\n  ;; o * e + $temp4 + carry\n  (set_local $temp4 (i64.add (i64.add (i64.mul (get_local $o) (get_local $e)) (i64.and (get_local $temp4) (i64.const 4294967295))) (i64.shr_u (get_local $temp3) (i64.const 32))))\n  ;; o * d + $temp5 + carry\n  (set_local $temp5 (i64.add (i64.add (i64.mul (get_local $o) (get_local $d)) (i64.and (get_local $temp5) (i64.const 4294967295))) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; o * c + $temp6 + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $o) (get_local $c)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; o * b + $temp7 + carry\n  (set_local $temp7 (i64.add (i64.add (i64.mul (get_local $o) (get_local $b)) (i64.and (get_local $temp7) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  ;; o * a + carry + rowCarry\n  (set_local $p (i64.add (i64.add (i64.mul (get_local $o) (get_local $a)) (i64.shr_u (get_local $temp7) (i64.const 32))) (get_local $rowCarry)))\n  (set_local $rowCarry (i64.shr_u (get_local $p) (i64.const 32)))\n\n  ;; third row - n\n  ;; n * h + $temp2 \n  (set_local $temp2 (i64.add (i64.mul (get_local $n) (get_local $h)) (i64.and (get_local $temp2) (i64.const 4294967295))))\n  ;; n * g + $temp3  carry\n  (set_local $temp3 (i64.add (i64.add (i64.mul (get_local $n) (get_local $g)) (i64.and (get_local $temp3) (i64.const 4294967295))) (i64.shr_u (get_local $temp2) (i64.const 32))))\n  ;; n * f + $temp4) + carry\n  (set_local $temp4 (i64.add (i64.add (i64.mul (get_local $n) (get_local $f)) (i64.and (get_local $temp4) (i64.const 4294967295))) (i64.shr_u (get_local $temp3) (i64.const 32))))\n  ;; n * e + $temp5 + carry\n  (set_local $temp5 (i64.add (i64.add (i64.mul (get_local $n) (get_local $e)) (i64.and (get_local $temp5) (i64.const 4294967295))) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; n * d + $temp6 + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $n) (get_local $d)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; n * c + $temp7 + carry\n  (set_local $temp7 (i64.add (i64.add (i64.mul (get_local $n) (get_local $c)) (i64.and (get_local $temp7) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  ;; n * b + $p + carry\n  (set_local $p     (i64.add (i64.add (i64.mul (get_local $n) (get_local $b)) (i64.and (get_local $p)     (i64.const 4294967295))) (i64.shr_u (get_local $temp7) (i64.const 32))))\n  ;; n * a + carry\n  (set_local $o (i64.add (i64.add (i64.mul (get_local $n) (get_local $a)) (i64.shr_u (get_local $p) (i64.const 32))) (get_local $rowCarry)))\n  (set_local $rowCarry (i64.shr_u (get_local $o) (i64.const 32)))\n\n  ;; forth row \n  ;; m * h + $temp3\n  (set_local $temp3 (i64.add (i64.mul (get_local $m) (get_local $h)) (i64.and (get_local $temp3) (i64.const 4294967295))))\n  ;; m * g + $temp4 + carry\n  (set_local $temp4 (i64.add (i64.add (i64.mul (get_local $m) (get_local $g)) (i64.and (get_local $temp4) (i64.const 4294967295))) (i64.shr_u (get_local $temp3) (i64.const 32))))\n  ;; m * f + $temp5 + carry\n  (set_local $temp5 (i64.add (i64.add (i64.mul (get_local $m) (get_local $f)) (i64.and (get_local $temp5) (i64.const 4294967295))) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; m * e + $temp6 + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $m) (get_local $e)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; m * d + $temp7 + carry\n  (set_local $temp7 (i64.add (i64.add (i64.mul (get_local $m) (get_local $d)) (i64.and (get_local $temp7) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  ;; m * c + $p + carry\n  (set_local $p     (i64.add (i64.add (i64.mul (get_local $m) (get_local $c)) (i64.and (get_local $p)     (i64.const 4294967295))) (i64.shr_u (get_local $temp7) (i64.const 32))))\n  ;; m * b + $o + carry\n  (set_local $o     (i64.add (i64.add (i64.mul (get_local $m) (get_local $b)) (i64.and (get_local $o)     (i64.const 4294967295))) (i64.shr_u (get_local $p)     (i64.const 32))))\n  ;; m * a + carry + rowCarry\n  (set_local $n     (i64.add (i64.add (i64.mul (get_local $m) (get_local $a)) (i64.shr_u (get_local $o) (i64.const 32))) (get_local $rowCarry)))\n  (set_local $rowCarry (i64.shr_u (get_local $n) (i64.const 32)))\n\n  ;; fith row\n  ;; l * h + $temp4\n  (set_local $temp4 (i64.add (i64.mul (get_local $l) (get_local $h)) (i64.and (get_local $temp4) (i64.const 4294967295))))\n  ;; l * g + $temp5 + carry\n  (set_local $temp5 (i64.add (i64.add (i64.mul (get_local $l) (get_local $g)) (i64.and (get_local $temp5) (i64.const 4294967295))) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; l * f + $temp6 + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $l) (get_local $f)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; l * e + $temp7 + carry\n  (set_local $temp7 (i64.add (i64.add (i64.mul (get_local $l) (get_local $e)) (i64.and (get_local $temp7) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  ;; l * d + $p + carry\n  (set_local $p     (i64.add (i64.add (i64.mul (get_local $l) (get_local $d)) (i64.and (get_local $p)     (i64.const 4294967295))) (i64.shr_u (get_local $temp7) (i64.const 32))))\n  ;; l * c + $o + carry\n  (set_local $o     (i64.add (i64.add (i64.mul (get_local $l) (get_local $c)) (i64.and (get_local $o)     (i64.const 4294967295))) (i64.shr_u (get_local $p)     (i64.const 32))))\n  ;; l * b + $n + carry\n  (set_local $n     (i64.add (i64.add (i64.mul (get_local $l) (get_local $b)) (i64.and (get_local $n)     (i64.const 4294967295))) (i64.shr_u (get_local $o)     (i64.const 32))))\n  ;; l * a + carry + rowCarry\n  (set_local $m     (i64.add (i64.add (i64.mul (get_local $l) (get_local $a)) (i64.shr_u (get_local $n) (i64.const 32))) (get_local $rowCarry)))\n  (set_local $rowCarry (i64.shr_u (get_local $m) (i64.const 32)))\n\n  ;; sixth row \n  ;; k * h + $temp5\n  (set_local $temp5 (i64.add (i64.mul (get_local $k) (get_local $h)) (i64.and (get_local $temp5) (i64.const 4294967295))))\n  ;; k * g + $temp6 + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $k) (get_local $g)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; k * f + $temp7 + carry\n  (set_local $temp7 (i64.add (i64.add (i64.mul (get_local $k) (get_local $f)) (i64.and (get_local $temp7) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  ;; k * e + $p + carry\n  (set_local $p     (i64.add (i64.add (i64.mul (get_local $k) (get_local $e)) (i64.and (get_local $p)     (i64.const 4294967295))) (i64.shr_u (get_local $temp7) (i64.const 32))))\n  ;; k * d + $o + carry\n  (set_local $o     (i64.add (i64.add (i64.mul (get_local $k) (get_local $d)) (i64.and (get_local $o)     (i64.const 4294967295))) (i64.shr_u (get_local $p)     (i64.const 32))))\n  ;; k * c + $n + carry\n  (set_local $n     (i64.add (i64.add (i64.mul (get_local $k) (get_local $c)) (i64.and (get_local $n)     (i64.const 4294967295))) (i64.shr_u (get_local $o)     (i64.const 32))))\n  ;; k * b + $m + carry\n  (set_local $m     (i64.add (i64.add (i64.mul (get_local $k) (get_local $b)) (i64.and (get_local $m)     (i64.const 4294967295))) (i64.shr_u (get_local $n)     (i64.const 32))))\n  ;; k * a + carry\n  (set_local $l     (i64.add (i64.add (i64.mul (get_local $k) (get_local $a)) (i64.shr_u (get_local $m) (i64.const 32))) (get_local $rowCarry)))\n  (set_local $rowCarry (i64.shr_u (get_local $l) (i64.const 32)))\n\n  ;; seventh row\n  ;; j * h + $temp6\n  (set_local $temp6 (i64.add (i64.mul (get_local $j) (get_local $h)) (i64.and (get_local $temp6) (i64.const 4294967295))))\n  ;; j * g + $temp7 + carry\n  (set_local $temp7 (i64.add (i64.add (i64.mul (get_local $j) (get_local $g)) (i64.and (get_local $temp7) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  ;; j * f + $p +carry\n  (set_local $p     (i64.add (i64.add (i64.mul (get_local $j) (get_local $f)) (i64.and (get_local $p)     (i64.const 4294967295))) (i64.shr_u (get_local $temp7) (i64.const 32))))\n  ;; j * e + $o + carry\n  (set_local $o     (i64.add (i64.add (i64.mul (get_local $j) (get_local $e)) (i64.and (get_local $o)     (i64.const 4294967295))) (i64.shr_u (get_local $p)     (i64.const 32))))\n  ;; j * d + $n + carry\n  (set_local $n     (i64.add (i64.add (i64.mul (get_local $j) (get_local $d)) (i64.and (get_local $n)     (i64.const 4294967295))) (i64.shr_u (get_local $o)     (i64.const 32))))\n  ;; j * c + $m + carry\n  (set_local $m     (i64.add (i64.add (i64.mul (get_local $j) (get_local $c)) (i64.and (get_local $m)     (i64.const 4294967295))) (i64.shr_u (get_local $n)     (i64.const 32))))\n  ;; j * b + $l + carry\n  (set_local $l     (i64.add (i64.add (i64.mul (get_local $j) (get_local $b)) (i64.and (get_local $l)     (i64.const 4294967295))) (i64.shr_u (get_local $m)     (i64.const 32))))\n  ;; j * a + carry\n  (set_local $k     (i64.add (i64.add (i64.mul (get_local $j) (get_local $a)) (i64.shr_u (get_local $l) (i64.const 32))) (get_local $rowCarry)))\n  (set_local $rowCarry (i64.shr_u (get_local $k) (i64.const 32)))\n\n  ;; eigth row\n  ;; i * h + $temp7 \n  (set_local $temp7 (i64.add (i64.mul (get_local $i) (get_local $h)) (i64.and (get_local $temp7) (i64.const 4294967295))))\n  ;; i * g + $p \n  (set_local $p     (i64.add (i64.add (i64.mul (get_local $i) (get_local $g)) (i64.and (get_local $p)     (i64.const 4294967295))) (i64.shr_u (get_local $temp7) (i64.const 32))))\n  ;; i * f + $o + carry\n  (set_local $o     (i64.add (i64.add (i64.mul (get_local $i) (get_local $f)) (i64.and (get_local $o)     (i64.const 4294967295))) (i64.shr_u (get_local $p)     (i64.const 32))))\n  ;; i * e + $n + carry\n  (set_local $n     (i64.add (i64.add (i64.mul (get_local $i) (get_local $e)) (i64.and (get_local $n)     (i64.const 4294967295))) (i64.shr_u (get_local $o)     (i64.const 32))))\n  ;; i * d + $m + carry\n  (set_local $m     (i64.add (i64.add (i64.mul (get_local $i) (get_local $d)) (i64.and (get_local $m)     (i64.const 4294967295))) (i64.shr_u (get_local $n)     (i64.const 32))))\n  ;; i * c + $l + carry\n  (set_local $l     (i64.add (i64.add (i64.mul (get_local $i) (get_local $c)) (i64.and (get_local $l)     (i64.const 4294967295))) (i64.shr_u (get_local $m)     (i64.const 32))))\n  ;; i * b + $k + carry\n  (set_local $k     (i64.add (i64.add (i64.mul (get_local $i) (get_local $b)) (i64.and (get_local $k)     (i64.const 4294967295))) (i64.shr_u (get_local $l)     (i64.const 32))))\n  ;; i * a + carry\n  (set_local $j     (i64.add (i64.add (i64.mul (get_local $i) (get_local $a)) (i64.shr_u (get_local $k) (i64.const 32))) (get_local $rowCarry)))\n\n  ;; combine terms\n  (set_local $a (get_local $j))\n  (set_local $b (i64.or (i64.shl (get_local $k)     (i64.const 32)) (i64.and (get_local $l)     (i64.const 4294967295))))\n  (set_local $c (i64.or (i64.shl (get_local $m)     (i64.const 32)) (i64.and (get_local $n)     (i64.const 4294967295))))\n  (set_local $d (i64.or (i64.shl (get_local $o)     (i64.const 32)) (i64.and (get_local $p)     (i64.const 4294967295))))\n  (set_local $e (i64.or (i64.shl (get_local $temp7) (i64.const 32)) (i64.and (get_local $temp6) (i64.const 4294967295))))\n  (set_local $f (i64.or (i64.shl (get_local $temp5) (i64.const 32)) (i64.and (get_local $temp4) (i64.const 4294967295))))\n  (set_local $g (i64.or (i64.shl (get_local $temp3) (i64.const 32)) (i64.and (get_local $temp2) (i64.const 4294967295))))\n  (set_local $h (i64.or (i64.shl (get_local $temp1) (i64.const 32)) (i64.and (get_local $temp0) (i64.const 4294967295))))\n\n  ;; pop the MOD argmunet off the stack\n  (set_local $moda (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $modb (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $modc (i64.load (i32.add (get_local $sp) (i32.const  8))))\n  (set_local $modd (i64.load          (get_local $sp)))\n\n  (call $mod_512\n         (get_local $a) (get_local $b) (get_local $c) (get_local $d) (get_local $e) (get_local $f) (get_local $g) (get_local $h) \n         (i64.const 0)  (i64.const 0) (i64.const 0)  (i64.const 0)  (get_local $moda) (get_local $modb) (get_local $modc) (get_local $modd) (i32.add (get_local $sp) (i32.const 24))\n  )\n)\n"
  },
  "NOT": {
    "wast": "(func $NOT\n  ;; FIXME: consider using 0xffffffffffffffff instead of -1?\n  (i64.store (i32.add (get_global $sp) (i32.const 24)) (i64.xor (i64.load (i32.add (get_global $sp) (i32.const 24))) (i64.const -1)))\n  (i64.store (i32.add (get_global $sp) (i32.const 16)) (i64.xor (i64.load (i32.add (get_global $sp) (i32.const 16))) (i64.const -1)))\n  (i64.store (i32.add (get_global $sp) (i32.const  8)) (i64.xor (i64.load (i32.add (get_global $sp) (i32.const  8))) (i64.const -1)))\n  (i64.store (i32.add (get_global $sp) (i32.const  0)) (i64.xor (i64.load (i32.add (get_global $sp) (i32.const  0))) (i64.const -1)))\n)\n"
  },
  "OR": {
    "wast": "(func $OR\n  (i64.store (i32.sub (get_global $sp) (i32.const  8)) (i64.or (i64.load (i32.sub (get_global $sp) (i32.const  8))) (i64.load (i32.add (get_global $sp) (i32.const 24)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 16)) (i64.or (i64.load (i32.sub (get_global $sp) (i32.const 16))) (i64.load (i32.add (get_global $sp) (i32.const 16)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 24)) (i64.or (i64.load (i32.sub (get_global $sp) (i32.const 24))) (i64.load (i32.add (get_global $sp) (i32.const  8)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 32)) (i64.or (i64.load (i32.sub (get_global $sp) (i32.const 32))) (i64.load          (get_global $sp))))\n)\n"
  },
  "PC": {
    "wast": "(func $PC\n  (param $pc i32)\n  (local $sp i32)\n\n  ;; add one to the stack\n  (set_local $sp (i32.add (get_global $sp) (i32.const 32)))\n  (i64.store (get_local $sp) (i64.extend_u/i32 (get_local $pc)))\n\n  ;; zero out rest of stack\n  (i64.store (i32.add (get_local $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "PUSH": {
    "wast": "(func $PUSH\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (local $sp i32)\n\n  ;; increament stack pointer\n  (set_local $sp (i32.add (get_global $sp) (i32.const 32)))\n\n  (i64.store (get_local $sp) (get_local $a3))\n  (i64.store (i32.add (get_local $sp) (i32.const 8)) (get_local $a2))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $a1))\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $a0))\n)\n"
  },
  "SDIV": {
    "wast": "(func $SDIV\n  (local $sp i32)\n\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp  i64)\n  (local $temp2 i64)\n  (local $sign i32)\n\n  (set_local $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (set_local $a (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $b (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $c (i64.load (i32.add (get_global $sp) (i32.const 8))))\n  (set_local $d (i64.load (get_global $sp)))\n\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $c1 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $d1 (i64.load (get_local $sp)))\n\n  ;; get the resulting sign\n  (set_local $sign (i32.wrap/i64 (i64.shr_u (i64.xor (get_local $a1) (get_local $a)) (i64.const 63))))\n\n  ;; convert to unsigned value\n  (if (i64.eqz (i64.clz (get_local $a)))\n    (then\n      (set_local $a (i64.xor (get_local $a) (i64.const -1)))\n      (set_local $b (i64.xor (get_local $b) (i64.const -1)))\n      (set_local $c (i64.xor (get_local $c) (i64.const -1)))\n      (set_local $d (i64.xor (get_local $d) (i64.const -1)))\n\n      ;; a = a + 1\n      (set_local $d (i64.add (get_local $d) (i64.const 1)))\n      (set_local $carry (i64.eqz (get_local $d)))\n      (set_local $c (i64.add (get_local $c) (i64.extend_u/i32 (get_local $carry))))\n      (set_local $carry (i32.and (i64.eqz (get_local $c)) (get_local $carry)))\n      (set_local $b (i64.add (get_local $b) (i64.extend_u/i32 (get_local $carry))))\n      (set_local $carry (i32.and (i64.eqz (get_local $b)) (get_local $carry)))\n      (set_local $a (i64.add (get_local $a) (i64.extend_u/i32 (get_local $carry))))\n    )\n  )\n  (if (i64.eqz (i64.clz (get_local $a1)))\n    (then\n      (set_local $a1 (i64.xor (get_local $a1) (i64.const -1)))\n      (set_local $b1 (i64.xor (get_local $b1) (i64.const -1)))\n      (set_local $c1 (i64.xor (get_local $c1) (i64.const -1)))\n      (set_local $d1 (i64.xor (get_local $d1) (i64.const -1)))\n\n      (set_local $d1 (i64.add (get_local $d1) (i64.const 1)))\n      (set_local $carry (i64.eqz (get_local $d1)))\n      (set_local $c1 (i64.add (get_local $c1) (i64.extend_u/i32 (get_local $carry))))\n      (set_local $carry (i32.and (i64.eqz (get_local $c1)) (get_local $carry)))\n      (set_local $b1 (i64.add (get_local $b1) (i64.extend_u/i32 (get_local $carry))))\n      (set_local $carry (i32.and (i64.eqz (get_local $b1)) (get_local $carry)))\n      (set_local $a1 (i64.add (get_local $a1) (i64.extend_u/i32 (get_local $carry))))\n    )\n  )\n  \n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1))\n      (br $main)\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (get_local $a1))) (call $gte_256 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $a) (get_local $b) (get_local $c) (get_local $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (set_local $a1 (i64.add (i64.shl (get_local $a1) (i64.const 1)) (i64.shr_u (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shl (get_local $b1) (i64.const 1)) (i64.shr_u (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shl (get_local $c1) (i64.const 1)) (i64.shr_u (get_local $d1) (i64.const 63))))\n        (set_local $d1 (i64.shl (get_local $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (set_local $maska (i64.add (i64.shl (get_local $maska) (i64.const 1)) (i64.shr_u (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shl (get_local $maskb) (i64.const 1)) (i64.shr_u (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shl (get_local $maskc) (i64.const 1)) (i64.shr_u (get_local $maskd) (i64.const 63))))\n        (set_local $maskd (i64.shl (get_local $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (get_local $maska) (get_local $maskb) (get_local $maskc) (get_local $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (get_local $a) (get_local $b) (get_local $c) (get_local $d) (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (set_local $carry (i64.lt_u (get_local $d) (get_local $d1)))\n            (set_local $d     (i64.sub  (get_local $d) (get_local $d1)))\n            (set_local $temp  (i64.sub  (get_local $c) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $c)))\n            (set_local $c     (i64.sub  (get_local $temp) (get_local $c1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $c) (get_local $temp)) (get_local $carry)))\n            (set_local $temp  (i64.sub  (get_local $b) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $b)))\n            (set_local $b     (i64.sub  (get_local $temp) (get_local $b1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $b) (get_local $temp)) (get_local $carry)))\n            (set_local $a     (i64.sub  (i64.sub (get_local $a) (i64.extend_u/i32 (get_local $carry))) (get_local $a1)))\n\n            ;; result = result + mask\n            (set_local $dq    (i64.add  (get_local $maskd) (get_local $dq)))\n            (set_local $carry (i64.lt_u (get_local $dq) (get_local $maskd)))\n            (set_local $temp  (i64.add  (get_local $cq) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.lt_u (get_local $temp) (get_local $cq)))\n            (set_local $cq    (i64.add  (get_local $maskc) (get_local $temp)))\n            (set_local $carry (i32.or   (i64.lt_u (get_local $cq) (get_local $maskc)) (get_local $carry)))\n            (set_local $temp  (i64.add  (get_local $bq) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.lt_u (get_local $temp) (get_local $bq)))\n            (set_local $bq    (i64.add  (get_local $maskb) (get_local $temp)))\n            (set_local $carry (i32.or   (i64.lt_u (get_local $bq) (get_local $maskb)) (get_local $carry)))\n            (set_local $aq    (i64.add  (get_local $maska) (i64.add (get_local $aq) (i64.extend_u/i32 (get_local $carry)))))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (set_local $d1 (i64.add (i64.shr_u (get_local $d1) (i64.const 1)) (i64.shl (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shr_u (get_local $c1) (i64.const 1)) (i64.shl (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shr_u (get_local $b1) (i64.const 1)) (i64.shl (get_local $a1) (i64.const 63))))\n        (set_local $a1 (i64.shr_u (get_local $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (set_local $maskd (i64.add (i64.shr_u (get_local $maskd) (i64.const 1)) (i64.shl (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shr_u (get_local $maskc) (i64.const 1)) (i64.shl (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shr_u (get_local $maskb) (i64.const 1)) (i64.shl (get_local $maska) (i64.const 63))))\n        (set_local $maska (i64.shr_u (get_local $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  ;; convert to signed\n  (if (get_local $sign)\n    (then\n      (set_local $aq (i64.xor (get_local $aq) (i64.const -1)))\n      (set_local $bq (i64.xor (get_local $bq) (i64.const -1)))\n      (set_local $cq (i64.xor (get_local $cq) (i64.const -1)))\n      (set_local $dq (i64.xor (get_local $dq) (i64.const -1)))\n\n      (set_local $dq (i64.add (get_local $dq) (i64.const 1)))\n      (set_local $cq (i64.add (get_local $cq) (i64.extend_u/i32 (i64.eqz (get_local $dq)))))\n      (set_local $bq (i64.add (get_local $bq) (i64.extend_u/i32 (i64.eqz (get_local $cq)))))\n      (set_local $aq (i64.add (get_local $aq) (i64.extend_u/i32 (i64.eqz (get_local $bq)))))\n    )\n  )\n\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $aq))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $bq))\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (get_local $cq))\n  (i64.store          (get_local $sp)                 (get_local $dq))\n)\n"
  },
  "SGT": {
    "wast": "(func $SGT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  ;; load args from the stack\n  (set_local $a0 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $a1 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $a2 (i64.load (i32.add (get_global $sp) (i32.const 8))))\n  (set_local $a3 (i64.load (get_global $sp)))\n\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n\n  (set_local $b0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $b2 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $b3 (i64.load (get_local $sp)))\n\n  (i64.store (get_local $sp) (i64.extend_u/i32 \n    (i32.or  (i64.gt_s (get_local $a0) (get_local $b0)) ;; a0 > b0\n    (i32.and (i64.eq   (get_local $a0) (get_local $b0)) ;; a0 == a1\n    (i32.or  (i64.gt_u (get_local $a1) (get_local $b1)) ;; a1 > b1\n    (i32.and (i64.eq   (get_local $a1) (get_local $b1)) ;; a1 == b1\n    (i32.or  (i64.gt_u (get_local $a2) (get_local $b2)) ;; a2 > b2\n    (i32.and (i64.eq   (get_local $a2) (get_local $b2)) ;; a2 == b2\n             (i64.gt_u (get_local $a3) (get_local $b3)))))))))) ;; a3 > b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SHA3": {
    "wast": "(func $SHA3\n  (local $dataOffset i32)\n  (local $dataOffset0 i64)\n  (local $dataOffset1 i64)\n  (local $dataOffset2 i64)\n  (local $dataOffset3 i64)\n\n  (local $length i32)\n  (local $length0 i64)\n  (local $length1 i64)\n  (local $length2 i64)\n  (local $length3 i64)\n\n  (local $contextOffset i32)\n  (local $outputOffset i32)\n\n  (set_local $length0 (i64.load (i32.sub (get_global $sp) (i32.const 32))))\n  (set_local $length1 (i64.load (i32.sub (get_global $sp) (i32.const 24))))\n  (set_local $length2 (i64.load (i32.sub (get_global $sp) (i32.const 16))))\n  (set_local $length3 (i64.load (i32.sub (get_global $sp) (i32.const 8))))\n\n  (set_local $dataOffset0 (i64.load (i32.add (get_global $sp) (i32.const 0))))\n  (set_local $dataOffset1 (i64.load (i32.add (get_global $sp) (i32.const 8))))\n  (set_local $dataOffset2 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $dataOffset3 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n\n  (set_local $length \n             (call $check_overflow (get_local $length0)\n                                   (get_local $length1)\n                                   (get_local $length2)\n                                   (get_local $length3)))\n  (set_local $dataOffset \n             (call $check_overflow (get_local $dataOffset0)\n                                   (get_local $dataOffset1)\n                                   (get_local $dataOffset2)\n                                   (get_local $dataOffset3)))\n\n  ;; charge copy fee ceil(words/32) * 6 \n  (call $useGas (i64.extend_u/i32 (i32.mul (i32.div_u (i32.add (get_local $length) (i32.const 31)) (i32.const 32)) (i32.const 6))))\n  (call $memusegas (get_local $dataOffset) (get_local $length))\n\n  (set_local $dataOffset (i32.add (get_global $memstart) (get_local $dataOffset)))\n\n  (set_local $contextOffset (i32.const 32808))\n  (set_local $outputOffset (i32.sub (get_global $sp) (i32.const 32)))\n\n  (call $keccak (get_local $contextOffset) (get_local $dataOffset) (get_local $length) (get_local $outputOffset))\n\n  (drop (call $bswap_m256 (get_local $outputOffset)))\n)\n"
  },
  "SIGNEXTEND": {
    "wast": "(func $SIGNEXTEND\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n  (local $sign i64)\n  (local $t i32)\n  (local $end i32)\n\n  (set_local $a0 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $a1 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $a2 (i64.load (i32.add (get_global $sp) (i32.const  8))))\n  (set_local $a3 (i64.load          (get_global $sp)))\n\n  (set_local $end (get_global $sp))\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n\n  (if (i32.and \n        (i32.and \n          (i32.and \n            (i64.lt_u (get_local $a3) (i64.const 32))\n            (i64.eqz (get_local $a2))) \n          (i64.eqz (get_local $a1)))\n        (i64.eqz (get_local $a0)))\n    (then\n      (set_local $t (i32.add (i32.wrap/i64 (get_local $a3)) (get_local $sp))) \n      (set_local $sign (i64.shr_s (i64.load8_s (get_local $t)) (i64.const 8)))\n      (set_local $t (i32.add (get_local $t) (i32.const 1)))\n      (block $done\n        (loop $loop\n          (if (i32.lt_u (get_local $end) (get_local $t))\n            (br $done)\n          )\n          (i64.store (get_local $t) (get_local $sign))\n          (set_local $t (i32.add (get_local $t) (i32.const 8)))\n          (br $loop)\n        )\n      )\n    )\n  )\n)\n\n"
  },
  "SLT": {
    "wast": "(func $SLT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  ;; load args from the stack\n  (set_local $a0 (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $a1 (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $a2 (i64.load (i32.add (get_global $sp) (i32.const 8))))\n  (set_local $a3 (i64.load (get_global $sp)))\n\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n\n  (set_local $b0 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $b2 (i64.load (i32.add (get_local $sp) (i32.const 8))))\n  (set_local $b3 (i64.load (get_local $sp)))\n\n  (i64.store (get_local $sp) (i64.extend_u/i32 \n    (i32.or  (i64.lt_s (get_local $a0) (get_local $b0)) ;; a0 < b0\n    (i32.and (i64.eq   (get_local $a0) (get_local $b0)) ;; a0 == b0\n    (i32.or  (i64.lt_u (get_local $a1) (get_local $b1)) ;; a1 < b1\n    (i32.and (i64.eq   (get_local $a1) (get_local $b1)) ;; a1 == b1\n    (i32.or  (i64.lt_u (get_local $a2) (get_local $b2)) ;; a2 < b2\n    (i32.and (i64.eq   (get_local $a2) (get_local $b2)) ;; a2 == b2\n             (i64.lt_u (get_local $a3) (get_local $b3)))))))))) ;; a3 < b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SMOD": {
    "wast": "(func $SMOD\n  (local $sp i32)\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $sign i32)\n  (local $temp  i64)\n  (local $temp2  i64)\n\n  ;; load args from the stack\n  (set_local $a (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $b (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $c (i64.load (i32.add (get_global $sp) (i32.const  8))))\n  (set_local $d (i64.load          (get_global $sp)))\n  ;; decement the stack pointer\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $c1 (i64.load (i32.add (get_local $sp) (i32.const  8))))\n  (set_local $d1 (i64.load          (get_local $sp)))\n\n  (set_local $maskd (i64.const 1))\n  (set_local $sign (i32.wrap/i64 (i64.shr_u (get_local $d) (i64.const 63))))\n\n  ;; convert to unsigned value\n  (if (i64.eqz (i64.clz (get_local $a)))\n    (then\n      (set_local $a (i64.xor (get_local $a) (i64.const -1)))\n      (set_local $b (i64.xor (get_local $b) (i64.const -1)))\n      (set_local $c (i64.xor (get_local $c) (i64.const -1)))\n      (set_local $d (i64.xor (get_local $d) (i64.const -1)))\n\n      ;; a = a + 1\n      (set_local $d (i64.add (get_local $d) (i64.const 1)))\n      (set_local $carry (i64.eqz (get_local $d)))\n      (set_local $c (i64.add (get_local $c) (i64.extend_u/i32 (get_local $carry))))\n      (set_local $carry (i32.and (i64.eqz (get_local $c)) (get_local $carry)))\n      (set_local $b (i64.add (get_local $b) (i64.extend_u/i32 (get_local $carry))))\n      (set_local $carry (i32.and (i64.eqz (get_local $b)) (get_local $carry)))\n      (set_local $a (i64.add (get_local $a) (i64.extend_u/i32 (get_local $carry))))\n    )\n  )\n\n  (if (i64.eqz (i64.clz (get_local $a1)))\n    (then\n      (set_local $a1 (i64.xor (get_local $a1) (i64.const -1)))\n      (set_local $b1 (i64.xor (get_local $b1) (i64.const -1)))\n      (set_local $c1 (i64.xor (get_local $c1) (i64.const -1)))\n      (set_local $d1 (i64.xor (get_local $d1) (i64.const -1)))\n\n      (set_local $d1 (i64.add (get_local $d1) (i64.const 1)))\n      (set_local $carry (i64.eqz (get_local $d1)))\n      (set_local $c1 (i64.add (get_local $c1) (i64.extend_u/i32 (get_local $carry))))\n      (set_local $carry (i32.and (i64.eqz (get_local $c1)) (get_local $carry)))\n      (set_local $b1 (i64.add (get_local $b1) (i64.extend_u/i32 (get_local $carry))))\n      (set_local $carry (i32.and (i64.eqz (get_local $b1)) (get_local $carry)))\n      (set_local $a1 (i64.add (get_local $a1) (i64.extend_u/i32 (get_local $carry))))\n    )\n  )\n  \n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1))\n      (then\n        (set_local $a (i64.const 0))\n        (set_local $b (i64.const 0))\n        (set_local $c (i64.const 0))\n        (set_local $d (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (get_local $a1))) (call $gte_256 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $a) (get_local $b) (get_local $c) (get_local $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (set_local $a1 (i64.add (i64.shl (get_local $a1) (i64.const 1)) (i64.shr_u (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shl (get_local $b1) (i64.const 1)) (i64.shr_u (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shl (get_local $c1) (i64.const 1)) (i64.shr_u (get_local $d1) (i64.const 63))))\n        (set_local $d1 (i64.shl (get_local $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (set_local $maska (i64.add (i64.shl (get_local $maska) (i64.const 1)) (i64.shr_u (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shl (get_local $maskb) (i64.const 1)) (i64.shr_u (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shl (get_local $maskc) (i64.const 1)) (i64.shr_u (get_local $maskd) (i64.const 63))))\n        (set_local $maskd (i64.shl (get_local $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (get_local $maska) (get_local $maskb) (get_local $maskc) (get_local $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (get_local $a) (get_local $b) (get_local $c) (get_local $d) (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (set_local $carry (i64.lt_u (get_local $d) (get_local $d1)))\n            (set_local $d     (i64.sub  (get_local $d) (get_local $d1)))\n            (set_local $temp  (i64.sub  (get_local $c) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $c)))\n            (set_local $c     (i64.sub  (get_local $temp) (get_local $c1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $c) (get_local $temp)) (get_local $carry)))\n            (set_local $temp  (i64.sub  (get_local $b) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $b)))\n            (set_local $b     (i64.sub  (get_local $temp) (get_local $b1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $b) (get_local $temp)) (get_local $carry)))\n            (set_local $a     (i64.sub  (i64.sub (get_local $a) (i64.extend_u/i32 (get_local $carry))) (get_local $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (set_local $d1 (i64.add (i64.shr_u (get_local $d1) (i64.const 1)) (i64.shl (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shr_u (get_local $c1) (i64.const 1)) (i64.shl (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shr_u (get_local $b1) (i64.const 1)) (i64.shl (get_local $a1) (i64.const 63))))\n        (set_local $a1 (i64.shr_u (get_local $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (set_local $maskd (i64.add (i64.shr_u (get_local $maskd) (i64.const 1)) (i64.shl (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shr_u (get_local $maskc) (i64.const 1)) (i64.shl (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shr_u (get_local $maskb) (i64.const 1)) (i64.shl (get_local $maska) (i64.const 63))))\n        (set_local $maska (i64.shr_u (get_local $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  )\n\n  ;; convert to signed\n  (if (get_local $sign)\n    (then\n      (set_local $a (i64.xor (get_local $a) (i64.const -1)))\n      (set_local $b (i64.xor (get_local $b) (i64.const -1)))\n      (set_local $c (i64.xor (get_local $c) (i64.const -1)))\n      (set_local $d (i64.xor (get_local $d) (i64.const -1)))\n\n      (set_local $d (i64.add (get_local $d) (i64.const 1)))\n      (set_local $c (i64.add (get_local $c) (i64.extend_u/i32 (i64.eqz (get_local $d)))))\n      (set_local $b (i64.add (get_local $b) (i64.extend_u/i32 (i64.eqz (get_local $c)))))\n      (set_local $a (i64.add (get_local $a) (i64.extend_u/i32 (i64.eqz (get_local $b)))))\n    )\n  )\n\n  ;; save the stack\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $a))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $b))\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (get_local $c))\n  (i64.store          (get_local $sp)                 (get_local $d))\n) ;; end for SMOD\n"
  },
  "SUB": {
    "wast": "(func $SUB\n  (local $sp i32)\n\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  (local $carry i64)\n  (local $temp i64)\n\n  (set_local $a (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $b (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $c (i64.load (i32.add (get_global $sp) (i32.const  8))))\n  (set_local $d (i64.load          (get_global $sp)))\n  ;; decement the stack pointer\n  (set_local $sp (i32.sub (get_global $sp) (i32.const 32)))\n\n  (set_local $a1 (i64.load (i32.add (get_local $sp) (i32.const 24))))\n  (set_local $b1 (i64.load (i32.add (get_local $sp) (i32.const 16))))\n  (set_local $c1 (i64.load (i32.add (get_local $sp) (i32.const  8))))\n  (set_local $d1 (i64.load          (get_local $sp)))\n\n  ;; a * 64^3 + b*64^2 + c*64 + d \n  ;; d\n  (set_local $carry (i64.extend_u/i32 (i64.lt_u (get_local $d) (get_local $d1))))\n  (set_local $d (i64.sub (get_local $d) (get_local $d1)))\n\n  ;; c\n  (set_local $temp (i64.sub (get_local $c) (get_local $carry)))\n  (set_local $carry (i64.extend_u/i32 (i64.gt_u (get_local $temp) (get_local $c))))\n  (set_local $c (i64.sub (get_local $temp) (get_local $c1)))\n  (set_local $carry (i64.or (i64.extend_u/i32 (i64.gt_u (get_local $c) (get_local $temp))) (get_local $carry)))\n\n  ;; b\n  (set_local $temp (i64.sub (get_local $b) (get_local $carry)))\n  (set_local $carry (i64.extend_u/i32 (i64.gt_u (get_local $temp) (get_local $b))))\n  (set_local $b (i64.sub (get_local $temp) (get_local $b1)))\n\n  ;; a\n  (set_local $a (i64.sub (i64.sub (get_local $a) (i64.or (i64.extend_u/i32 (i64.gt_u (get_local $b) (get_local $temp))) (get_local $carry))) (get_local $a1)))\n\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $a))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $b))\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (get_local $c))\n  (i64.store          (get_local $sp)                 (get_local $d))\n)\n"
  },
  "SWAP": {
    "wast": "(func $SWAP\n  (param $a0 i32)\n  (local $sp_ref i32)\n\n  (local $topa i64)\n  (local $topb i64)\n  (local $topc i64)\n  (local $topd i64)\n  \n  (set_local $sp_ref (i32.sub (i32.add  (get_global $sp) (i32.const 24)) (i32.mul (i32.add (get_local $a0) (i32.const 1)) (i32.const 32))))\n\n  (set_local $topa (i64.load (i32.add (get_global $sp) (i32.const 24))))\n  (set_local $topb (i64.load (i32.add (get_global $sp) (i32.const 16))))\n  (set_local $topc (i64.load (i32.add (get_global $sp) (i32.const  8))))\n  (set_local $topd (i64.load          (get_global $sp)))\n  \n  ;; replace the top element\n  (i64.store (i32.add (get_global $sp) (i32.const 24)) (i64.load (get_local $sp_ref)))\n  (i64.store (i32.add (get_global $sp) (i32.const 16)) (i64.load (i32.sub (get_local $sp_ref) (i32.const 8))))\n  (i64.store (i32.add (get_global $sp) (i32.const  8)) (i64.load (i32.sub (get_local $sp_ref) (i32.const 16))))\n  (i64.store          (get_global $sp)                 (i64.load (i32.sub (get_local $sp_ref) (i32.const 24))))\n\n  ;; store the old top element\n  (i64.store (get_local $sp_ref)                          (get_local $topa))\n  (i64.store (i32.sub (get_local $sp_ref) (i32.const 8))  (get_local $topb))\n  (i64.store (i32.sub (get_local $sp_ref) (i32.const 16)) (get_local $topc))\n  (i64.store (i32.sub (get_local $sp_ref) (i32.const 24)) (get_local $topd))\n)\n"
  },
  "XOR": {
    "wast": "(func $XOR\n  (i64.store (i32.sub (get_global $sp) (i32.const  8)) (i64.xor (i64.load (i32.sub (get_global $sp) (i32.const  8))) (i64.load (i32.add (get_global $sp) (i32.const 24)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 16)) (i64.xor (i64.load (i32.sub (get_global $sp) (i32.const 16))) (i64.load (i32.add (get_global $sp) (i32.const 16)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 24)) (i64.xor (i64.load (i32.sub (get_global $sp) (i32.const 24))) (i64.load (i32.add (get_global $sp) (i32.const  8)))))\n  (i64.store (i32.sub (get_global $sp) (i32.const 32)) (i64.xor (i64.load (i32.sub (get_global $sp) (i32.const 32))) (i64.load (i32.add (get_global $sp) (i32.const  0)))))\n)\n"
  },
  "bswap_i32": {
    "wast": "(func $bswap_i32\n  (param $int i32)\n  (result i32)\n\n  (i32.or\n    (i32.or\n      (i32.and (i32.shr_u (get_local $int) (i32.const 24)) (i32.const 0xff)) ;; 7 -> 0\n      (i32.and (i32.shr_u (get_local $int) (i32.const 8)) (i32.const 0xff00))) ;; 6 -> 1\n    (i32.or\n      (i32.and (i32.shl (get_local $int) (i32.const 8)) (i32.const 0xff0000)) ;; 5 -> 2\n      (i32.and (i32.shl (get_local $int) (i32.const 24)) (i32.const 0xff000000)))) ;; 4 -> 3\n)\n"
  },
  "bswap_i64": {
    "wast": "(func $bswap_i64\n  (param $int i64)\n  (result i64)\n\n  (i64.or\n    (i64.or\n      (i64.or\n        (i64.and (i64.shr_u (get_local $int) (i64.const 56)) (i64.const 0xff)) ;; 7 -> 0\n        (i64.and (i64.shr_u (get_local $int) (i64.const 40)) (i64.const 0xff00))) ;; 6 -> 1\n      (i64.or\n        (i64.and (i64.shr_u (get_local $int) (i64.const 24)) (i64.const 0xff0000)) ;; 5 -> 2\n        (i64.and (i64.shr_u (get_local $int) (i64.const  8)) (i64.const 0xff000000)))) ;; 4 -> 3\n    (i64.or\n      (i64.or\n        (i64.and (i64.shl (get_local $int) (i64.const 8))   (i64.const 0xff00000000)) ;; 3 -> 4\n        (i64.and (i64.shl (get_local $int) (i64.const 24))   (i64.const 0xff0000000000))) ;; 2 -> 5\n      (i64.or\n        (i64.and (i64.shl (get_local $int) (i64.const 40))   (i64.const 0xff000000000000)) ;; 1 -> 6\n        (i64.and (i64.shl (get_local $int) (i64.const 56))   (i64.const 0xff00000000000000))))) ;; 0 -> 7\n)\n"
  },
  "bswap_m128": {
    "wast": "(func $bswap_m128\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (set_local $temp (call $bswap_i64 (i64.load (get_local $sp))))\n  (i64.store (get_local $sp) (call $bswap_i64 (i64.load (i32.add (get_local $sp) (i32.const 8)))))\n  (i64.store (i32.add (get_local $sp) (i32.const 8)) (get_local $temp))\n  (get_local $sp)\n)\n"
  },
  "bswap_m160": {
    "wast": "(func $bswap_m160\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (set_local $temp (call $bswap_i64 (i64.load (get_local $sp))))\n  (i64.store (get_local $sp) (call $bswap_i64 (i64.load (i32.add (get_local $sp) (i32.const 12)))))\n  (i64.store (i32.add (get_local $sp) (i32.const 12)) (get_local $temp))\n\n  (i32.store (i32.add (get_local $sp) (i32.const 8)) (call $bswap_i32 (i32.load (i32.add (get_local $sp) (i32.const 8)))))\n  (get_local $sp)\n)\n"
  },
  "bswap_m256": {
    "wast": "(func $bswap_m256\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (set_local $temp (call $bswap_i64 (i64.load (get_local $sp))))\n  (i64.store (get_local $sp) (call $bswap_i64 (i64.load (i32.add (get_local $sp) (i32.const 24)))))\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $temp))\n\n  (set_local $temp (call $bswap_i64 (i64.load (i32.add (get_local $sp) (i32.const 8)))))\n  (i64.store (i32.add (get_local $sp) (i32.const  8)) (call $bswap_i64 (i64.load (i32.add (get_local $sp) (i32.const 16)))))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $temp))\n  (get_local $sp)\n)\n"
  },
  "callback": {
    "wast": "(func $callback\n  (call $main)\n)\n"
  },
  "callback_128": {
    "wast": "(func $callback_128\n  (param $result i32)\n\n  (drop (call $bswap_m128 (get_global $sp)))\n  (call $main)\n)\n"
  },
  "callback_160": {
    "wast": "(func $callback_160\n  (param $result i32)\n\n  (drop (call $bswap_m160 (get_global $sp)))\n  (call $main)\n)\n"
  },
  "callback_256": {
    "wast": "(func $callback_256\n  (param $result i32)\n\n  (drop (call $bswap_m256 (get_global $sp)))\n  (call $main)\n)\n"
  },
  "callback_32": {
    "wast": "(func $callback_32\n  (param $result i32)\n\n  (i64.store (get_global $sp) (i64.extend_u/i32 (get_local $result)))\n  ;; zero out mem\n  (i64.store (i32.add (get_global $sp) (i32.const 24)) (i64.const 0))\n  (i64.store (i32.add (get_global $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (get_global $sp) (i32.const 8)) (i64.const 0))\n\n  (call $main)\n)\n"
  },
  "check_overflow": {
    "wast": "(func $check_overflow\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (result i32)\n\n  (local $MAX_INT i32)\n  (set_local $MAX_INT (i32.const -1))\n\n  (if\n    (i32.and \n      (i32.and \n        (i64.eqz  (get_local $d))\n        (i64.eqz  (get_local $c)))\n      (i32.and \n        (i64.eqz  (get_local $b))\n        (i64.lt_u (get_local $a) (i64.extend_u/i32 (get_local $MAX_INT)))))\n     (return (i32.wrap/i64 (get_local $a))))\n\n     (return (get_local $MAX_INT))\n)\n"
  },
  "check_overflow_i64": {
    "wast": "(func $check_overflow_i64\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (result i64)\n\n  (if\n    (i32.and \n      (i32.and \n        (i64.eqz  (get_local $d))\n        (i64.eqz  (get_local $c)))\n      (i64.eqz  (get_local $b)))\n    (return (get_local $a)))\n\n    (return (i64.const 0xffffffffffffffff))\n)\n"
  },
  "gte_256": {
    "wast": ";; is a less than or equal to b // a >= b\n(func $gte_256\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (get_local $a0) (get_local $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (get_local $a0) (get_local $b0))\n  (i32.or  (i64.gt_u (get_local $a1) (get_local $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (get_local $a1) (get_local $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (get_local $a2) (get_local $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (get_local $a2) (get_local $b2))\n           (i64.ge_u (get_local $a3) (get_local $b3))))))))\n)\n"
  },
  "gte_320": {
    "wast": "(func $gte_320\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (param $a4 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n  (param $b4 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (get_local $a0) (get_local $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (get_local $a0) (get_local $b0))\n  (i32.or  (i64.gt_u (get_local $a1) (get_local $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (get_local $a1) (get_local $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (get_local $a2) (get_local $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (get_local $a2) (get_local $b2))\n  (i32.or  (i64.gt_u (get_local $a3) (get_local $b3)) ;; a2 > b2\n  (i32.and (i64.eq   (get_local $a3) (get_local $b3))\n           (i64.ge_u (get_local $a4) (get_local $b4))))))))))\n)\n"
  },
  "gte_512": {
    "wast": "(func $gte_512\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (param $a4 i64)\n  (param $a5 i64)\n  (param $a6 i64)\n  (param $a7 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n  (param $b4 i64)\n  (param $b5 i64)\n  (param $b6 i64)\n  (param $b7 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (get_local $a0) (get_local $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (get_local $a0) (get_local $b0))\n  (i32.or  (i64.gt_u (get_local $a1) (get_local $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (get_local $a1) (get_local $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (get_local $a2) (get_local $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (get_local $a2) (get_local $b2))\n  (i32.or  (i64.gt_u (get_local $a3) (get_local $b3)) ;; a3 > b3\n  (i32.and (i64.eq   (get_local $a3) (get_local $b3))\n  (i32.or  (i64.gt_u (get_local $a4) (get_local $b4)) ;; a4 > b4\n  (i32.and (i64.eq   (get_local $a4) (get_local $b4))\n  (i32.or  (i64.gt_u (get_local $a5) (get_local $b5)) ;; a5 > b5\n  (i32.and (i64.eq   (get_local $a5) (get_local $b5))\n  (i32.or  (i64.gt_u (get_local $a6) (get_local $b6)) ;; a6 > b6\n  (i32.and (i64.eq   (get_local $a6) (get_local $b6))\n           (i64.ge_u (get_local $a7) (get_local $b7))))))))))))))))\n)\n"
  },
  "iszero_256": {
    "wast": "(func $iszero_256\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n\n  (i64.eqz (i64.or (i64.or (i64.or (get_local 0) (get_local 1)) (get_local 2)) (get_local 3))) \n)\n"
  },
  "iszero_320": {
    "wast": "(func $iszero_320\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n\n  (i64.eqz (i64.or (i64.or (i64.or (i64.or (get_local 0) (get_local 1)) (get_local 2)) (get_local 3)) (get_local 4)))\n)\n"
  },
  "iszero_512": {
    "wast": "(func $iszero_512\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n  (i64.eqz (i64.or (i64.or (i64.or (i64.or (i64.or (i64.or (i64.or (get_local 0) (get_local 1)) (get_local 2)) (get_local 3)) (get_local 4)) (get_local 5)) (get_local 6)) (get_local 7)))\n)\n"
  },
  "keccak": {
    "wast": ";;\n;; Copied from https://github.com/axic/keccak-wasm (has more comments)\n;;\n\n(func $keccak_theta\n  (param $context_offset i32)\n\n  (local $C0 i64)\n  (local $C1 i64)\n  (local $C2 i64)\n  (local $C3 i64)\n  (local $C4 i64)\n  (local $D0 i64)\n  (local $D1 i64)\n  (local $D2 i64)\n  (local $D3 i64)\n  (local $D4 i64)\n\n  ;; C[x] = A[x] ^ A[x + 5] ^ A[x + 10] ^ A[x + 15] ^ A[x + 20];\n  (set_local $C0\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 0)))\n      (i64.xor\n        (i64.load (i32.add (get_local $context_offset) (i32.const 40)))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.const 80)))\n          (i64.xor\n            (i64.load (i32.add (get_local $context_offset) (i32.const 120)))\n            (i64.load (i32.add (get_local $context_offset) (i32.const 160)))\n          )\n        )\n      )\n    )\n  )\n\n  (set_local $C1\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 8)))\n      (i64.xor\n        (i64.load (i32.add (get_local $context_offset) (i32.const 48)))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.const 88)))\n          (i64.xor\n            (i64.load (i32.add (get_local $context_offset) (i32.const 128)))\n            (i64.load (i32.add (get_local $context_offset) (i32.const 168)))\n          )\n        )\n      )\n    )\n  )\n\n  (set_local $C2\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 16)))\n      (i64.xor\n        (i64.load (i32.add (get_local $context_offset) (i32.const 56)))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.const 96)))\n          (i64.xor\n            (i64.load (i32.add (get_local $context_offset) (i32.const 136)))\n            (i64.load (i32.add (get_local $context_offset) (i32.const 176)))\n          )\n        )\n      )\n    )\n  )\n\n  (set_local $C3\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 24)))\n      (i64.xor\n        (i64.load (i32.add (get_local $context_offset) (i32.const 64)))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.const 104)))\n          (i64.xor\n            (i64.load (i32.add (get_local $context_offset) (i32.const 144)))\n            (i64.load (i32.add (get_local $context_offset) (i32.const 184)))\n          )\n        )\n      )\n    )\n  )\n\n  (set_local $C4\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 32)))\n      (i64.xor\n        (i64.load (i32.add (get_local $context_offset) (i32.const 72)))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.const 112)))\n          (i64.xor\n            (i64.load (i32.add (get_local $context_offset) (i32.const 152)))\n            (i64.load (i32.add (get_local $context_offset) (i32.const 192)))\n          )\n        )\n      )\n    )\n  )\n\n  ;; D[0] = ROTL64(C[1], 1) ^ C[4];\n  (set_local $D0\n    (i64.xor\n      (get_local $C4)\n      (i64.rotl\n        (get_local $C1)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[1] = ROTL64(C[2], 1) ^ C[0];\n  (set_local $D1\n    (i64.xor\n      (get_local $C0)\n      (i64.rotl\n        (get_local $C2)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[2] = ROTL64(C[3], 1) ^ C[1];\n  (set_local $D2\n    (i64.xor\n      (get_local $C1)\n      (i64.rotl\n        (get_local $C3)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[3] = ROTL64(C[4], 1) ^ C[2];\n  (set_local $D3\n    (i64.xor\n      (get_local $C2)\n      (i64.rotl\n        (get_local $C4)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[4] = ROTL64(C[0], 1) ^ C[3];\n  (set_local $D4\n    (i64.xor\n      (get_local $C3)\n      (i64.rotl\n        (get_local $C0)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; A[x]      ^= D[x];\n  ;; A[x + 5]  ^= D[x];\n  ;; A[x + 10] ^= D[x];\n  ;; A[x + 15] ^= D[x];\n  ;; A[x + 20] ^= D[x];\n  \n  ;; x = 0\n  (i64.store (i32.add (get_local $context_offset) (i32.const 0))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 0)))\n      (get_local $D0)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 40))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 40)))\n      (get_local $D0)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 80))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 80)))\n      (get_local $D0)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 120))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 120)))\n      (get_local $D0)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 160))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 160)))\n      (get_local $D0)\n    )\n  )\n\n  ;; x = 1\n  (i64.store (i32.add (get_local $context_offset) (i32.const 8))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 8)))\n      (get_local $D1)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 48))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 48)))\n      (get_local $D1)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 88))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 88)))\n      (get_local $D1)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 128))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 128)))\n      (get_local $D1)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 168))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 168)))\n      (get_local $D1)\n    )\n  )\n\n  ;; x = 2\n  (i64.store (i32.add (get_local $context_offset) (i32.const 16))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 16)))\n      (get_local $D2)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 56))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 56)))\n      (get_local $D2)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 96))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 96)))\n      (get_local $D2)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 136))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 136)))\n      (get_local $D2)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 176))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 176)))\n      (get_local $D2)\n    )\n  )\n\n  ;; x = 3\n  (i64.store (i32.add (get_local $context_offset) (i32.const 24))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 24)))\n      (get_local $D3)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 64))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 64)))\n      (get_local $D3)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 104))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 104)))\n      (get_local $D3)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 144))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 144)))\n      (get_local $D3)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 184))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 184)))\n      (get_local $D3)\n    )\n  )\n\n  ;; x = 4\n  (i64.store (i32.add (get_local $context_offset) (i32.const 32))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 32)))\n      (get_local $D4)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 72))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 72)))\n      (get_local $D4)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 112))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 112)))\n      (get_local $D4)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 152))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 152)))\n      (get_local $D4)\n    )\n  )\n\n  (i64.store (i32.add (get_local $context_offset) (i32.const 192))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 192)))\n      (get_local $D4)\n    )\n  )\n)\n\n(func $keccak_rho\n  (param $context_offset i32)\n  (param $rotation_consts i32)\n\n  ;;(local $tmp i32)\n\n  ;; state[ 1] = ROTL64(state[ 1],  1);\n  ;;(set_local $tmp (i32.add (get_local $context_offset) (i32.const 1)))\n  ;;(i64.store (get_local $tmp) (i64.rotl (i64.load (get_local $context_offset)) (i64.const 1)))\n\n  ;;(set_local $tmp (i32.add (get_local $context_offset) (i32.const 2)))\n  ;;(i64.store (get_local $tmp) (i64.rotl (i64.load (get_local $context_offset)) (i64.const 62)))\n\n  (local $tmp i32)\n  (local $i i32)\n\n  ;; for (i = 0; i <= 24; i++)\n  (set_local $i (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (get_local $i) (i32.const 24))\n        (br $done)\n      )\n\n      (set_local $tmp (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (i32.const 1) (get_local $i)))))\n\n      (i64.store (get_local $tmp) (i64.rotl (i64.load (get_local $tmp)) (i64.load8_u (i32.add (get_local $rotation_consts) (get_local $i)))))\n\n      (set_local $i (i32.add (get_local $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n)\n\n(func $keccak_pi\n  (param $context_offset i32)\n\n  (local $A1 i64)\n  (set_local $A1 (i64.load (i32.add (get_local $context_offset) (i32.const 8))))\n\n  ;; Swap non-overlapping fields, i.e. $A1 = $A6, etc.\n  ;; NOTE: $A0 is untouched\n  (i64.store (i32.add (get_local $context_offset) (i32.const 8)) (i64.load (i32.add (get_local $context_offset) (i32.const 48))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 48)) (i64.load (i32.add (get_local $context_offset) (i32.const 72))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 72)) (i64.load (i32.add (get_local $context_offset) (i32.const 176))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 176)) (i64.load (i32.add (get_local $context_offset) (i32.const 112))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 112)) (i64.load (i32.add (get_local $context_offset) (i32.const 160))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 160)) (i64.load (i32.add (get_local $context_offset) (i32.const 16))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 16)) (i64.load (i32.add (get_local $context_offset) (i32.const 96))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 96)) (i64.load (i32.add (get_local $context_offset) (i32.const 104))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 104)) (i64.load (i32.add (get_local $context_offset) (i32.const 152))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 152)) (i64.load (i32.add (get_local $context_offset) (i32.const 184))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 184)) (i64.load (i32.add (get_local $context_offset) (i32.const 120))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 120)) (i64.load (i32.add (get_local $context_offset) (i32.const 32))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 32)) (i64.load (i32.add (get_local $context_offset) (i32.const 192))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 192)) (i64.load (i32.add (get_local $context_offset) (i32.const 168))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 168)) (i64.load (i32.add (get_local $context_offset) (i32.const 64))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 64)) (i64.load (i32.add (get_local $context_offset) (i32.const 128))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 128)) (i64.load (i32.add (get_local $context_offset) (i32.const 40))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 40)) (i64.load (i32.add (get_local $context_offset) (i32.const 24))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 24)) (i64.load (i32.add (get_local $context_offset) (i32.const 144))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 144)) (i64.load (i32.add (get_local $context_offset) (i32.const 136))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 136)) (i64.load (i32.add (get_local $context_offset) (i32.const 88))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 88)) (i64.load (i32.add (get_local $context_offset) (i32.const 56))))\n  (i64.store (i32.add (get_local $context_offset) (i32.const 56)) (i64.load (i32.add (get_local $context_offset) (i32.const 80))))\n\n  ;; Place the previously saved overlapping field\n  (i64.store (i32.add (get_local $context_offset) (i32.const 80)) (get_local $A1))\n)\n\n(func $keccak_chi\n  (param $context_offset i32)\n\n  (local $A0 i64)\n  (local $A1 i64)\n  (local $i i32)\n\n  ;; for (round = 0; round < 25; i += 5)\n  (set_local $i (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (get_local $i) (i32.const 25))\n        (br $done)\n      )\n\n      (set_local $A0 (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (get_local $i)))))\n      (set_local $A1 (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 1))))))\n\n      ;; A[0 + i] ^= ~A1 & A[2 + i];\n      (i64.store (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (get_local $i)))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (get_local $i))))\n          (i64.and\n            (i64.xor (get_local $A1) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 2)))))\n          )\n        )\n      )\n\n      ;; A[1 + i] ^= ~A[2 + i] & A[3 + i];\n      (i64.store (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 1))))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 1)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 2))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 3)))))\n          )\n        )\n      )\n\n      ;; A[2 + i] ^= ~A[3 + i] & A[4 + i];\n      (i64.store (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 2))))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 2)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 3))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 4)))))\n          )\n        )\n      )\n\n      ;; A[3 + i] ^= ~A[4 + i] & A0;\n      (i64.store (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 3))))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 3)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 4))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (get_local $A0)\n          )\n        )\n      )\n\n      ;; A[4 + i] ^= ~A0 & A1;\n      (i64.store (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 4))))\n        (i64.xor\n          (i64.load (i32.add (get_local $context_offset) (i32.mul (i32.const 8) (i32.add (get_local $i) (i32.const 4)))))\n          (i64.and\n            (i64.xor (get_local $A0) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (get_local $A1)\n          )\n        )\n      )\n\n      (set_local $i (i32.add (get_local $i) (i32.const 5)))\n      (br $loop)\n    )\n  )\n)\n\n(func $keccak_permute\n  (param $context_offset i32)\n\n  (local $rotation_consts i32)\n  (local $round_consts i32)\n  (local $round i32)\n\n  (set_local $round_consts (i32.add (get_local $context_offset) (i32.const 400)))\n  (set_local $rotation_consts (i32.add (get_local $context_offset) (i32.const 592)))\n\n  ;; for (round = 0; round < 24; round++)\n  (set_local $round (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (get_local $round) (i32.const 24))\n        (br $done)\n      )\n\n      ;; theta transform\n      (call $keccak_theta (get_local $context_offset))\n\n      ;; rho transform\n      (call $keccak_rho (get_local $context_offset) (get_local $rotation_consts))\n\n      ;; pi transform\n      (call $keccak_pi (get_local $context_offset))\n\n      ;; chi transform\n      (call $keccak_chi (get_local $context_offset))\n\n      ;; iota transform\n      ;; context_offset[0] ^= KECCAK_ROUND_CONSTANTS[round];\n      (i64.store (get_local $context_offset)\n        (i64.xor\n          (i64.load (get_local $context_offset))\n          (i64.load (i32.add (get_local $round_consts) (i32.mul (i32.const 8) (get_local $round))))\n        )\n      )\n\n      (set_local $round (i32.add (get_local $round) (i32.const 1)))\n      (br $loop)\n    )  \n  ) \n)\n\n(func $keccak_block\n  (param $input_offset i32)\n  (param $input_length i32) ;; ignored, we expect keccak256\n  (param $context_offset i32)\n\n  ;; read blocks in little-endian order and XOR against context_offset\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 0))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 0)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 0)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 8))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 8)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 8)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 16))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 16)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 16)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 24))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 24)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 24)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 32))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 32)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 32)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 40))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 40)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 40)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 48))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 48)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 48)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 56))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 56)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 56)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 64))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 64)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 64)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 72))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 72)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 72)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 80))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 80)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 80)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 88))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 88)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 88)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 96))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 96)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 96)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 104))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 104)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 104)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 112))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 112)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 112)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 120))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 120)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 120)))\n    )\n  )\n\n  (i64.store\n    (i32.add (get_local $context_offset) (i32.const 128))\n    (i64.xor\n      (i64.load (i32.add (get_local $context_offset) (i32.const 128)))\n      (i64.load (i32.add (get_local $input_offset) (i32.const 128)))\n    )\n  )\n  \n  (call $keccak_permute (get_local $context_offset))\n)\n\n;;\n;; Initialise the context\n;;\n(func $keccak_init\n  (param $context_offset i32)\n  (local $round_consts i32)\n  (local $rotation_consts i32)\n\n  (call $keccak_reset (get_local $context_offset))\n\n  ;; insert the round constants (used by $KECCAK_IOTA)\n  (set_local $round_consts (i32.add (get_local $context_offset) (i32.const 400)))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 0)) (i64.const 0x0000000000000001))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 8)) (i64.const 0x0000000000008082))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 16)) (i64.const 0x800000000000808A))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 24)) (i64.const 0x8000000080008000))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 32)) (i64.const 0x000000000000808B))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 40)) (i64.const 0x0000000080000001))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 48)) (i64.const 0x8000000080008081))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 56)) (i64.const 0x8000000000008009))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 64)) (i64.const 0x000000000000008A))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 72)) (i64.const 0x0000000000000088))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 80)) (i64.const 0x0000000080008009))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 88)) (i64.const 0x000000008000000A))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 96)) (i64.const 0x000000008000808B))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 104)) (i64.const 0x800000000000008B))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 112)) (i64.const 0x8000000000008089))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 120)) (i64.const 0x8000000000008003))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 128)) (i64.const 0x8000000000008002))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 136)) (i64.const 0x8000000000000080))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 144)) (i64.const 0x000000000000800A))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 152)) (i64.const 0x800000008000000A))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 160)) (i64.const 0x8000000080008081))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 168)) (i64.const 0x8000000000008080))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 176)) (i64.const 0x0000000080000001))\n  (i64.store (i32.add (get_local $round_consts) (i32.const 184)) (i64.const 0x8000000080008008))\n\n  ;; insert the rotation constants (used by $keccak_rho)\n  (set_local $rotation_consts (i32.add (get_local $context_offset) (i32.const 592)))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 0)) (i32.const 1))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 1)) (i32.const 62))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 2)) (i32.const 28))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 3)) (i32.const 27))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 4)) (i32.const 36))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 5)) (i32.const 44))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 6)) (i32.const 6))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 7)) (i32.const 55))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 8)) (i32.const 20))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 9)) (i32.const 3))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 10)) (i32.const 10))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 11)) (i32.const 43))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 12)) (i32.const 25))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 13)) (i32.const 39))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 14)) (i32.const 41))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 15)) (i32.const 45))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 16)) (i32.const 15))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 17)) (i32.const 21))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 18)) (i32.const 8))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 19)) (i32.const 18))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 20)) (i32.const 2))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 21)) (i32.const 61))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 22)) (i32.const 56))\n  (i32.store8 (i32.add (get_local $rotation_consts) (i32.const 23)) (i32.const 14))\n)\n\n;;\n;; Reset the context\n;;\n(func $keccak_reset\n  (param $context_offset i32)\n\n  ;; clear out the context memory\n  (drop (call $memset (get_local $context_offset) (i32.const 0) (i32.const 400)))\n)\n\n;;\n;; Push input to the context\n;;\n(func $keccak_update\n  (param $context_offset i32)\n  (param $input_offset i32)\n  (param $input_length i32)\n\n  (local $residue_offset i32)\n  (local $residue_buffer i32)\n  (local $residue_index i32)\n  (local $tmp i32)\n\n  ;; this is where we store the pointer\n  (set_local $residue_offset (i32.add (get_local $context_offset) (i32.const 200)))\n  ;; this is where the buffer is\n  (set_local $residue_buffer (i32.add (get_local $context_offset) (i32.const 208)))\n\n  (set_local $residue_index (i32.load (get_local $residue_offset)))\n\n  ;; process residue from last block\n  (if (i32.ne (get_local $residue_index) (i32.const 0))\n    (then\n      ;; the space left in the residue buffer\n      (set_local $tmp (i32.sub (i32.const 136) (get_local $residue_index)))\n\n      ;; limit to what we have as an input\n      (if (i32.lt_u (get_local $input_length) (get_local $tmp))\n        (set_local $tmp (get_local $input_length))\n      )\n\n      ;; fill up the residue buffer\n      (drop (call $memcpy\n        (i32.add (get_local $residue_buffer) (get_local $residue_index))\n        (get_local $input_offset)\n        (get_local $tmp)\n      ))\n\n      (set_local $residue_index (i32.add (get_local $residue_index) (get_local $tmp)))\n\n      ;; block complete\n      (if (i32.eq (get_local $residue_index) (i32.const 136))\n        (call $keccak_block (get_local $input_offset) (i32.const 136) (get_local $context_offset))\n\n        (set_local $residue_index (i32.const 0))\n      )\n\n      (i32.store (get_local $residue_offset) (get_local $residue_index))\n\n      (set_local $input_length (i32.sub (get_local $input_length) (get_local $tmp)))\n    )\n  )\n\n  ;; while (input_length > block_size)\n  (block $done\n    (loop $loop\n      (if (i32.lt_u (get_local $input_length) (i32.const 136))\n        (br $done)\n      )\n\n      (call $keccak_block (get_local $input_offset) (i32.const 136) (get_local $context_offset))\n\n      (set_local $input_offset (i32.add (get_local $input_offset) (i32.const 136)))\n      (set_local $input_length (i32.sub (get_local $input_length) (i32.const 136)))\n      (br $loop)\n    )\n  )\n\n  ;; copy to the residue buffer\n  (if (i32.gt_u (get_local $input_length) (i32.const 0))\n    (then\n      (drop (call $memcpy\n        (i32.add (get_local $residue_buffer) (get_local $residue_index))\n        (get_local $input_offset)\n        (get_local $input_length)\n      ))\n\n      (set_local $residue_index (i32.add (get_local $residue_index) (get_local $input_length)))\n      (i32.store (get_local $residue_offset) (get_local $residue_index))\n    )\n  )\n)\n\n;;\n;; Finalise and return the hash\n;;\n;; The 256 bit hash is returned at the output offset.\n;;\n(func $keccak_finish\n  (param $context_offset i32)\n  (param $output_offset i32)\n\n  (local $residue_offset i32)\n  (local $residue_buffer i32)\n  (local $residue_index i32)\n  (local $tmp i32)\n\n  ;; this is where we store the pointer\n  (set_local $residue_offset (i32.add (get_local $context_offset) (i32.const 200)))\n  ;; this is where the buffer is\n  (set_local $residue_buffer (i32.add (get_local $context_offset) (i32.const 208)))\n\n  (set_local $residue_index (i32.load (get_local $residue_offset)))\n  (set_local $tmp (get_local $residue_index))\n\n  ;; clear the rest of the residue buffer\n  (drop (call $memset (i32.add (get_local $residue_buffer) (get_local $tmp)) (i32.const 0) (i32.sub (i32.const 136) (get_local $tmp))))\n\n  ;; ((char*)ctx->message)[ctx->rest] |= 0x01;\n  (set_local $tmp (i32.add (get_local $residue_buffer) (get_local $residue_index)))\n  (i32.store8 (get_local $tmp) (i32.or (i32.load8_u (get_local $tmp)) (i32.const 0x01)))\n\n  ;; ((char*)ctx->message)[block_size - 1] |= 0x80;\n  (set_local $tmp (i32.add (get_local $residue_buffer) (i32.const 135)))\n  (i32.store8 (get_local $tmp) (i32.or (i32.load8_u (get_local $tmp)) (i32.const 0x80)))\n\n  (call $keccak_block (get_local $residue_buffer) (i32.const 136) (get_local $context_offset))\n\n  ;; the first 32 bytes pointed at by $output_offset is the final hash\n  (i64.store (get_local $output_offset) (i64.load (get_local $context_offset)))\n  (i64.store (i32.add (get_local $output_offset) (i32.const 8)) (i64.load (i32.add (get_local $context_offset) (i32.const 8))))\n  (i64.store (i32.add (get_local $output_offset) (i32.const 16)) (i64.load (i32.add (get_local $context_offset) (i32.const 16))))\n  (i64.store (i32.add (get_local $output_offset) (i32.const 24)) (i64.load (i32.add (get_local $context_offset) (i32.const 24))))\n)\n\n;;\n;; Calculate the hash. Helper method incorporating the above three.\n;;\n(func $keccak\n  (param $context_offset i32)\n  (param $input_offset i32)\n  (param $input_length i32)\n  (param $output_offset i32)\n\n  (call $keccak_init (get_local $context_offset))\n  (call $keccak_update (get_local $context_offset) (get_local $input_offset) (get_local $input_length))\n  (call $keccak_finish (get_local $context_offset) (get_local $output_offset))\n)\n"
  },
  "memcpy": {
    "wast": ";;\n;; memcpy from ewasm-libc/ewasm-cleanup\n;;\n(func $memcpy\n  (param $dst i32)\n  (param $src i32)\n  (param $length i32)\n  (result i32)\n\n  (local $i i32)\n\n  (set_local $i (i32.const 0))\n\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (get_local $i) (get_local $length))\n        (br $done)\n      )\n\n      (i32.store8 (i32.add (get_local $dst) (get_local $i)) (i32.load8_u (i32.add (get_local $src) (get_local $i))))\n\n      (set_local $i (i32.add (get_local $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n\n  (return (get_local $dst))\n)\n"
  },
  "memset": {
    "wast": ";;\n;; memcpy from ewasm-libc/ewasm-cleanup\n;;\n(func $memset\n  (param $ptr i32)\n  (param $value i32)\n  (param $length i32)\n  (result i32)\n  (local $i i32)\n\n  (set_local $i (i32.const 0))\n\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (get_local $i) (get_local $length))\n        (br $done)\n      )\n\n      (i32.store8 (i32.add (get_local $ptr) (get_local $i)) (get_local $value))\n\n      (set_local $i (i32.add (get_local $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n  (get_local $ptr)\n)\n"
  },
  "memusegas": {
    "wast": "(func $memusegas\n  (param $offset i32)\n  (param $length i32)\n\n  (local $cost i64)\n  ;; the number of new words being allocated\n  (local $newWordCount i64)\n\n  (if (i32.eqz (get_local $length))\n    (then (return))\n  )\n\n  ;; const newMemoryWordCount = Math.ceil[[offset + length] / 32]\n  (set_local $newWordCount \n    (i64.div_u (i64.add (i64.const 31) (i64.add (i64.extend_u/i32 (get_local $offset)) (i64.extend_u/i32 (get_local $length))))\n               (i64.const 32)))\n\n  ;;if [runState.highestMem >= highestMem]  return\n  (if (i64.le_u (get_local $newWordCount) (get_global $wordCount))\n    (then (return))\n  )\n\n  ;; words * 3 + words ^2 / 512\n  (set_local $cost\n     (i64.add\n       (i64.mul (get_local $newWordCount) (i64.const 3))\n       (i64.div_u\n         (i64.mul (get_local $newWordCount)\n                  (get_local $newWordCount))\n         (i64.const 512))))\n\n  (call $useGas  (i64.sub (get_local $cost) (get_global $prevMemCost)))\n  (set_global $prevMemCost (get_local $cost))\n  (set_global $wordCount (get_local $newWordCount))\n\n  ;; grow actual memory\n  ;; the first 31704 bytes are guaranteed to be available\n  ;; adjust for 32 bytes  - the maximal size of MSTORE write\n  ;; TODO it should be current_memory * page_size\n  (set_local $offset (i32.add (get_local $length) (i32.add (get_local $offset) (get_global $memstart))))\n  (if (i32.gt_u (get_local $offset) (i32.mul (i32.const 65536) (current_memory)))\n    (then\n      (drop (grow_memory\n        (i32.div_u (i32.add (i32.const 65535) (i32.sub (get_local $offset) (current_memory))) (i32.const 65536))))\n    )\n  )\n)\n"
  },
  "mod_320": {
    "wast": "(func $mod_320\n  ;; dividend\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (param $e i64)\n\n  ;; divisor\n  (param $a1 i64)\n  (param $b1 i64)\n  (param $c1 i64)\n  (param $d1 i64)\n  (param $e1 i64)\n\n  ;; stack pointer\n  (param $sp i32)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n  (local $eq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $maske i64)\n\n  (local $carry i32)\n  (local $temp i64)\n\n  (set_local $maske (i64.const 1))\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_320 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $e1)) \n      (then\n        (set_local $a (i64.const 0))\n        (set_local $b (i64.const 0))\n        (set_local $c (i64.const 0))\n        (set_local $d (i64.const 0))\n        (set_local $e (i64.const 0))\n        (br $main)\n      )\n    )\n\n    (block $done\n      ;; align bits\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (get_local $a1))) (call $gte_320\n                                                            (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $e1)\n                                                            (get_local $a) (get_local $b) (get_local $c) (get_local $d) (get_local $e)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (set_local $a1 (i64.add (i64.shl (get_local $a1) (i64.const 1)) (i64.shr_u (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shl (get_local $b1) (i64.const 1)) (i64.shr_u (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shl (get_local $c1) (i64.const 1)) (i64.shr_u (get_local $d1) (i64.const 63))))\n        (set_local $d1 (i64.add (i64.shl (get_local $d1) (i64.const 1)) (i64.shr_u (get_local $e1) (i64.const 63))))\n        (set_local $e1 (i64.shl (get_local $e1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (set_local $maska (i64.add (i64.shl (get_local $maska) (i64.const 1)) (i64.shr_u (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shl (get_local $maskb) (i64.const 1)) (i64.shr_u (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shl (get_local $maskc) (i64.const 1)) (i64.shr_u (get_local $maskd) (i64.const 63))))\n        (set_local $maskd (i64.add (i64.shl (get_local $maskd) (i64.const 1)) (i64.shr_u (get_local $maske) (i64.const 63))))\n        (set_local $maske (i64.shl (get_local $maske) (i64.const 1)))\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_320 (get_local $maska) (get_local $maskb) (get_local $maskc) (get_local $maskd) (get_local $maske))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_320 (get_local $a) (get_local $b) (get_local $c) (get_local $d) (get_local $e) (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $e1))\n          (then\n            ;; dividend = dividend - divisor\n            (set_local $carry (i64.lt_u (get_local $e) (get_local $e1)))\n            (set_local $e     (i64.sub  (get_local $e) (get_local $e1)))\n\n            (set_local $temp  (i64.sub  (get_local $d) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $d)))\n            (set_local $d     (i64.sub  (get_local $temp) (get_local $d1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $d) (get_local $temp)) (get_local $carry)))\n\n            (set_local $temp  (i64.sub  (get_local $c) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $c)))\n            (set_local $c     (i64.sub  (get_local $temp) (get_local $c1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $c) (get_local $temp)) (get_local $carry)))\n\n            (set_local $temp  (i64.sub  (get_local $b) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $b)))\n            (set_local $b     (i64.sub  (get_local $temp) (get_local $b1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $b) (get_local $temp)) (get_local $carry)))\n\n            (set_local $a     (i64.sub  (i64.sub (get_local $a) (i64.extend_u/i32 (get_local $carry))) (get_local $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (set_local $e1 (i64.add (i64.shr_u (get_local $e1) (i64.const 1)) (i64.shl (get_local $d1) (i64.const 63))))\n        (set_local $d1 (i64.add (i64.shr_u (get_local $d1) (i64.const 1)) (i64.shl (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shr_u (get_local $c1) (i64.const 1)) (i64.shl (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shr_u (get_local $b1) (i64.const 1)) (i64.shl (get_local $a1) (i64.const 63))))\n        (set_local $a1 (i64.shr_u (get_local $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (set_local $maske (i64.add (i64.shr_u (get_local $maske) (i64.const 1)) (i64.shl (get_local $maskd) (i64.const 63))))\n        (set_local $maskd (i64.add (i64.shr_u (get_local $maskd) (i64.const 1)) (i64.shl (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shr_u (get_local $maskc) (i64.const 1)) (i64.shl (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shr_u (get_local $maskb) (i64.const 1)) (i64.shl (get_local $maska) (i64.const 63))))\n        (set_local $maska (i64.shr_u (get_local $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n  (i64.store (i32.add (get_local $sp) (i32.const 24)) (get_local $b))\n  (i64.store (i32.add (get_local $sp) (i32.const 16)) (get_local $c))\n  (i64.store (i32.add (get_local $sp) (i32.const 8))  (get_local $d))\n  (i64.store (get_local $sp)                          (get_local $e))\n)\n"
  },
  "mod_512": {
    "wast": ";; Modulo 0x06\n(func $mod_512\n  ;; dividend\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (param $e i64)\n  (param $f i64)\n  (param $g i64)\n  (param $h i64)\n\n  ;; divisor\n  (param $a1 i64)\n  (param $b1 i64)\n  (param $c1 i64)\n  (param $d1 i64)\n  (param $e1 i64)\n  (param $f1 i64)\n  (param $g1 i64)\n  (param $h1 i64)\n\n  (param $sp i32)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $maske i64)\n  (local $maskf i64)\n  (local $maskg i64)\n  (local $maskh i64)\n\n  (local $carry i32)\n  (local $temp i64)\n\n  (set_local $maskh (i64.const 1))\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_512 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $e1) (get_local $f1) (get_local $g1) (get_local $h1))\n      (then\n        (set_local $e (i64.const 0))\n        (set_local $f (i64.const 0))\n        (set_local $g (i64.const 0))\n        (set_local $h (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (get_local $a1)))\n          (call $gte_512 (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $e1) (get_local $f1) (get_local $g1) (get_local $h1)\n                         (get_local $a)  (get_local $b)  (get_local $c)  (get_local $d)  (get_local $e)  (get_local $f)  (get_local $g)  (get_local $h)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (set_local $a1 (i64.add (i64.shl (get_local $a1) (i64.const 1)) (i64.shr_u (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shl (get_local $b1) (i64.const 1)) (i64.shr_u (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shl (get_local $c1) (i64.const 1)) (i64.shr_u (get_local $d1) (i64.const 63))))\n        (set_local $d1 (i64.add (i64.shl (get_local $d1) (i64.const 1)) (i64.shr_u (get_local $e1) (i64.const 63))))\n        (set_local $e1 (i64.add (i64.shl (get_local $e1) (i64.const 1)) (i64.shr_u (get_local $f1) (i64.const 63))))\n        (set_local $f1 (i64.add (i64.shl (get_local $f1) (i64.const 1)) (i64.shr_u (get_local $g1) (i64.const 63))))\n        (set_local $g1 (i64.add (i64.shl (get_local $g1) (i64.const 1)) (i64.shr_u (get_local $h1) (i64.const 63))))\n        (set_local $h1 (i64.shl (get_local $h1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (set_local $maska (i64.add (i64.shl (get_local $maska) (i64.const 1)) (i64.shr_u (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shl (get_local $maskb) (i64.const 1)) (i64.shr_u (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shl (get_local $maskc) (i64.const 1)) (i64.shr_u (get_local $maskd) (i64.const 63))))\n        (set_local $maskd (i64.add (i64.shl (get_local $maskd) (i64.const 1)) (i64.shr_u (get_local $maske) (i64.const 63))))\n        (set_local $maske (i64.add (i64.shl (get_local $maske) (i64.const 1)) (i64.shr_u (get_local $maskf) (i64.const 63))))\n        (set_local $maskf (i64.add (i64.shl (get_local $maskf) (i64.const 1)) (i64.shr_u (get_local $maskg) (i64.const 63))))\n        (set_local $maskg (i64.add (i64.shl (get_local $maskg) (i64.const 1)) (i64.shr_u (get_local $maskh) (i64.const 63))))\n        (set_local $maskh (i64.shl (get_local $maskh) (i64.const 1)))\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_512 (get_local $maska) (get_local $maskb) (get_local $maskc) (get_local $maskd) (get_local $maske) (get_local $maskf) (get_local $maskg) (get_local $maskh))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_512 \n          (get_local $a)  (get_local $b)  (get_local $c)  (get_local $d)  (get_local $e)  (get_local $f)  (get_local $g)  (get_local $h)\n          (get_local $a1) (get_local $b1) (get_local $c1) (get_local $d1) (get_local $e1) (get_local $f1) (get_local $g1) (get_local $h1))\n          (then\n            ;; dividend = dividend - divisor\n            (set_local $carry (i64.lt_u (get_local $h) (get_local $h1)))\n            (set_local $h     (i64.sub  (get_local $h) (get_local $h1)))\n\n            (set_local $temp  (i64.sub  (get_local $g) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $g)))\n            (set_local $g     (i64.sub  (get_local $temp) (get_local $g1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $g) (get_local $temp)) (get_local $carry)))\n\n            (set_local $temp  (i64.sub  (get_local $f) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $f)))\n            (set_local $f     (i64.sub  (get_local $temp) (get_local $f1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $f) (get_local $temp)) (get_local $carry)))\n\n            (set_local $temp  (i64.sub  (get_local $e) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $e)))\n            (set_local $e     (i64.sub  (get_local $temp) (get_local $e1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $e) (get_local $temp)) (get_local $carry)))\n\n            (set_local $temp  (i64.sub  (get_local $d) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $d)))\n            (set_local $d     (i64.sub  (get_local $temp) (get_local $d1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $d) (get_local $temp)) (get_local $carry)))\n\n            (set_local $temp  (i64.sub  (get_local $c) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $c)))\n            (set_local $c     (i64.sub  (get_local $temp) (get_local $c1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $c) (get_local $temp)) (get_local $carry)))\n\n            (set_local $temp  (i64.sub  (get_local $b) (i64.extend_u/i32 (get_local $carry))))\n            (set_local $carry (i64.gt_u (get_local $temp) (get_local $b)))\n            (set_local $b     (i64.sub  (get_local $temp) (get_local $b1)))\n            (set_local $carry (i32.or   (i64.gt_u (get_local $b) (get_local $temp)) (get_local $carry)))\n            (set_local $a     (i64.sub  (i64.sub (get_local $a) (i64.extend_u/i32 (get_local $carry))) (get_local $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (set_local $h1 (i64.add (i64.shr_u (get_local $h1) (i64.const 1)) (i64.shl (get_local $g1) (i64.const 63))))\n        (set_local $g1 (i64.add (i64.shr_u (get_local $g1) (i64.const 1)) (i64.shl (get_local $f1) (i64.const 63))))\n        (set_local $f1 (i64.add (i64.shr_u (get_local $f1) (i64.const 1)) (i64.shl (get_local $e1) (i64.const 63))))\n        (set_local $e1 (i64.add (i64.shr_u (get_local $e1) (i64.const 1)) (i64.shl (get_local $d1) (i64.const 63))))\n        (set_local $d1 (i64.add (i64.shr_u (get_local $d1) (i64.const 1)) (i64.shl (get_local $c1) (i64.const 63))))\n        (set_local $c1 (i64.add (i64.shr_u (get_local $c1) (i64.const 1)) (i64.shl (get_local $b1) (i64.const 63))))\n        (set_local $b1 (i64.add (i64.shr_u (get_local $b1) (i64.const 1)) (i64.shl (get_local $a1) (i64.const 63))))\n        (set_local $a1 (i64.shr_u (get_local $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (set_local $maskh (i64.add (i64.shr_u (get_local $maskh) (i64.const 1)) (i64.shl (get_local $maskg) (i64.const 63))))\n        (set_local $maskg (i64.add (i64.shr_u (get_local $maskg) (i64.const 1)) (i64.shl (get_local $maskf) (i64.const 63))))\n        (set_local $maskf (i64.add (i64.shr_u (get_local $maskf) (i64.const 1)) (i64.shl (get_local $maske) (i64.const 63))))\n        (set_local $maske (i64.add (i64.shr_u (get_local $maske) (i64.const 1)) (i64.shl (get_local $maskd) (i64.const 63))))\n        (set_local $maskd (i64.add (i64.shr_u (get_local $maskd) (i64.const 1)) (i64.shl (get_local $maskc) (i64.const 63))))\n        (set_local $maskc (i64.add (i64.shr_u (get_local $maskc) (i64.const 1)) (i64.shl (get_local $maskb) (i64.const 63))))\n        (set_local $maskb (i64.add (i64.shr_u (get_local $maskb) (i64.const 1)) (i64.shl (get_local $maska) (i64.const 63))))\n        (set_local $maska (i64.shr_u (get_local $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (get_local $sp) (get_local $e))\n  (i64.store (i32.sub (get_local $sp) (i32.const 8)) (get_local $f))\n  (i64.store (i32.sub (get_local $sp) (i32.const 16)) (get_local $g))\n  (i64.store (i32.sub (get_local $sp) (i32.const 24)) (get_local $h))\n)\n"
  },
  "mul_256": {
    "wast": "(func $mul_256\n  ;;  a b c d e f g h\n  ;;* i j k l m n o p\n  ;;----------------\n  (param $a i64)\n  (param $c i64)\n  (param $e i64)\n  (param $g i64)\n\n  (param $i i64)\n  (param $k i64)\n  (param $m i64)\n  (param $o i64)\n\n  (param $sp i32)\n\n  (local $b i64)\n  (local $d i64)\n  (local $f i64)\n  (local $h i64)\n  (local $j i64)\n  (local $l i64)\n  (local $n i64)\n  (local $p i64)\n  (local $temp6 i64)\n  (local $temp5 i64)\n  (local $temp4 i64)\n  (local $temp3 i64)\n  (local $temp2 i64)\n  (local $temp1 i64)\n  (local $temp0 i64)\n\n  ;; split the ops\n  (set_local $b (i64.and (get_local $a) (i64.const 4294967295)))\n  (set_local $a (i64.shr_u (get_local $a) (i64.const 32))) \n\n  (set_local $d (i64.and (get_local $c) (i64.const 4294967295)))\n  (set_local $c (i64.shr_u (get_local $c) (i64.const 32))) \n\n  (set_local $f (i64.and (get_local $e) (i64.const 4294967295)))\n  (set_local $e (i64.shr_u (get_local $e) (i64.const 32)))\n\n  (set_local $h (i64.and (get_local $g) (i64.const 4294967295)))\n  (set_local $g (i64.shr_u (get_local $g) (i64.const 32)))\n\n  (set_local $j (i64.and (get_local $i) (i64.const 4294967295)))\n  (set_local $i (i64.shr_u (get_local $i) (i64.const 32))) \n\n  (set_local $l (i64.and (get_local $k) (i64.const 4294967295)))\n  (set_local $k (i64.shr_u (get_local $k) (i64.const 32))) \n\n  (set_local $n (i64.and (get_local $m) (i64.const 4294967295)))\n  (set_local $m (i64.shr_u (get_local $m) (i64.const 32)))\n\n  (set_local $p (i64.and (get_local $o) (i64.const 4294967295)))\n  (set_local $o (i64.shr_u (get_local $o) (i64.const 32)))\n  ;; first row multiplication \n  ;; p * h\n  (set_local $temp0 (i64.mul (get_local $p) (get_local $h)))\n  ;; p * g + carry\n  (set_local $temp1 (i64.add (i64.mul (get_local $p) (get_local $g)) (i64.shr_u (get_local $temp0) (i64.const 32))))\n  ;; p * f + carry\n  (set_local $temp2 (i64.add (i64.mul (get_local $p) (get_local $f)) (i64.shr_u (get_local $temp1) (i64.const 32))))\n  ;; p * e + carry\n  (set_local $temp3 (i64.add (i64.mul (get_local $p) (get_local $e)) (i64.shr_u (get_local $temp2) (i64.const 32))))\n  ;; p * d + carry\n  (set_local $temp4 (i64.add (i64.mul (get_local $p) (get_local $d)) (i64.shr_u (get_local $temp3) (i64.const 32))))\n  ;; p * c + carry\n  (set_local $temp5  (i64.add (i64.mul (get_local $p) (get_local $c)) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; p * b + carry\n  (set_local $temp6  (i64.add (i64.mul (get_local $p) (get_local $b)) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; p * a + carry\n  (set_local $a  (i64.add (i64.mul (get_local $p) (get_local $a)) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  ;; second row\n  ;; o * h + $temp1 \"pg\"\n  (set_local $temp1 (i64.add (i64.mul (get_local $o) (get_local $h)) (i64.and (get_local $temp1) (i64.const 4294967295))))\n  ;; o * g + $temp2 \"pf\" + carry\n  (set_local $temp2 (i64.add (i64.add (i64.mul (get_local $o) (get_local $g)) (i64.and (get_local $temp2) (i64.const 4294967295))) (i64.shr_u (get_local $temp1) (i64.const 32))))\n  ;; o * f + $temp3 \"pe\" + carry\n  (set_local $temp3 (i64.add (i64.add (i64.mul (get_local $o) (get_local $f)) (i64.and (get_local $temp3) (i64.const 4294967295))) (i64.shr_u (get_local $temp2) (i64.const 32))))\n  ;; o * e + $temp4  + carry\n  (set_local $temp4 (i64.add (i64.add (i64.mul (get_local $o) (get_local $e)) (i64.and (get_local $temp4) (i64.const 4294967295))) (i64.shr_u (get_local $temp3) (i64.const 32))))\n  ;; o * d + $temp5  + carry\n  (set_local $temp5 (i64.add (i64.add (i64.mul (get_local $o) (get_local $d)) (i64.and (get_local $temp5) (i64.const 4294967295))) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; o * c + $temp6  + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $o) (get_local $c)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; o * b + $a  + carry\n  (set_local $a (i64.add (i64.add (i64.mul (get_local $o) (get_local $b)) (i64.and (get_local $a) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n  ;; third row - n\n  ;; n * h + $temp2 \n  (set_local $temp2 (i64.add (i64.mul (get_local $n) (get_local $h)) (i64.and (get_local $temp2) (i64.const 4294967295))))\n  ;; n * g + $temp3 + carry\n  (set_local $temp3 (i64.add (i64.add (i64.mul (get_local $n) (get_local $g)) (i64.and (get_local $temp3) (i64.const 4294967295))) (i64.shr_u (get_local $temp2) (i64.const 32))))\n  ;; n * f + $temp4 + carry\n  (set_local $temp4 (i64.add (i64.add (i64.mul (get_local $n) (get_local $f)) (i64.and (get_local $temp4) (i64.const 4294967295))) (i64.shr_u (get_local $temp3) (i64.const 32))))\n  ;; n * e + $temp5  + carry\n  (set_local $temp5 (i64.add (i64.add (i64.mul (get_local $n) (get_local $e)) (i64.and (get_local $temp5) (i64.const 4294967295))) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; n * d + $temp6  + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $n) (get_local $d)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; n * c + $a  + carry\n  (set_local $a (i64.add (i64.add (i64.mul (get_local $n) (get_local $c)) (i64.and (get_local $a) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n\n  ;; forth row \n  ;; m * h + $temp3\n  (set_local $temp3 (i64.add (i64.mul (get_local $m) (get_local $h)) (i64.and (get_local $temp3) (i64.const 4294967295))))\n  ;; m * g + $temp4 + carry\n  (set_local $temp4 (i64.add (i64.add (i64.mul (get_local $m) (get_local $g)) (i64.and (get_local $temp4) (i64.const 4294967295))) (i64.shr_u (get_local $temp3) (i64.const 32))))\n  ;; m * f + $temp5 + carry\n  (set_local $temp5 (i64.add (i64.add (i64.mul (get_local $m) (get_local $f)) (i64.and (get_local $temp5) (i64.const 4294967295))) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; m * e + $temp6 + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $m) (get_local $e)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; m * d + $a + carry\n  (set_local $a (i64.add (i64.add (i64.mul (get_local $m) (get_local $d)) (i64.and (get_local $a) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n\n  ;; fith row\n  ;; l * h + $temp4\n  (set_local $temp4 (i64.add (i64.mul (get_local $l) (get_local $h)) (i64.and (get_local $temp4) (i64.const 4294967295))))\n  ;; l * g + $temp5 + carry\n  (set_local $temp5 (i64.add (i64.add (i64.mul (get_local $l) (get_local $g)) (i64.and (get_local $temp5) (i64.const 4294967295))) (i64.shr_u (get_local $temp4) (i64.const 32))))\n  ;; l * f + $temp6 + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $l) (get_local $f)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; l * e + $a + carry\n  (set_local $a (i64.add (i64.add (i64.mul (get_local $l) (get_local $e)) (i64.and (get_local $a) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n\n  ;; sixth row \n  ;; k * h + $temp5\n  (set_local $temp5 (i64.add (i64.mul (get_local $k) (get_local $h)) (i64.and (get_local $temp5) (i64.const 4294967295))))\n  ;; k * g + $temp6 + carry\n  (set_local $temp6 (i64.add (i64.add (i64.mul (get_local $k) (get_local $g)) (i64.and (get_local $temp6) (i64.const 4294967295))) (i64.shr_u (get_local $temp5) (i64.const 32))))\n  ;; k * f + $a + carry\n  (set_local $a (i64.add (i64.add (i64.mul (get_local $k) (get_local $f)) (i64.and (get_local $a) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))))\n\n  ;; seventh row\n  ;; j * h + $temp6\n  (set_local $temp6 (i64.add (i64.mul (get_local $j) (get_local $h)) (i64.and (get_local $temp6) (i64.const 4294967295))))\n  ;; j * g + $a + carry\n\n  ;; eigth row\n  ;; i * h + $a\n  (set_local $a (i64.add (i64.mul (get_local $i) (get_local $h)) (i64.and (i64.add (i64.add (i64.mul (get_local $j) (get_local $g)) (i64.and (get_local $a) (i64.const 4294967295))) (i64.shr_u (get_local $temp6) (i64.const 32))) (i64.const 4294967295))))\n\n  ;; combine terms\n  (set_local $a (i64.or (i64.shl (get_local $a) (i64.const 32)) (i64.and (get_local $temp6) (i64.const 4294967295))))\n  (set_local $c (i64.or (i64.shl (get_local $temp5) (i64.const 32)) (i64.and (get_local $temp4) (i64.const 4294967295))))\n  (set_local $e (i64.or (i64.shl (get_local $temp3) (i64.const 32)) (i64.and (get_local $temp2) (i64.const 4294967295))))\n  (set_local $g (i64.or (i64.shl (get_local $temp1) (i64.const 32)) (i64.and (get_local $temp0) (i64.const 4294967295))))\n\n  ;; save stack \n  (i64.store (get_local $sp) (get_local $a))\n  (i64.store (i32.sub (get_local $sp) (i32.const 8)) (get_local $c))\n  (i64.store (i32.sub (get_local $sp) (i32.const 16)) (get_local $e))\n  (i64.store (i32.sub (get_local $sp) (i32.const 24)) (get_local $g))\n)\n"
  }
}